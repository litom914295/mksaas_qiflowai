# 现成开源玄空风水罗盘推荐

## 🧑‍💻 User

帮我看看我的这个AI八字风水项目，要找个开源的玄空风水罗盘替换原有罗盘，要求在手机上好用，比较专业，好看高大上的，你推荐下

---
## 🤖 Assistant

> search("帮我看看我的这个AI八字风水项目，要找个开源的玄空风水罗盘替换原有罗盘，要求在手机上好用，比较专业，好看高大上的，你推荐下")

不错，这是个有意思的需求 — 要找开源的玄空风水罗盘／罗盘组件，用于手机端，好看又专业。下面我先给你一个评估标准 + 可选的现成开源或接近开源的方案，然后给你建议怎么定制／整合。

---

## 评估标准（你可以据此挑选／验收一个组件）

为了保证手机上“好用＋专业＋高大上”，以下这些点是关键：

| 维度 | 要求 |
|---|---|
| **视觉设计** | 圆盘足够大、刻度清晰、美观（字体、色彩、排版、层次）、支持高 DPI / Retina 显示，有动画效果或渐变等现代设计感。 |
| **交互体验** | 响应触摸/滑动旋转、支持旋转罗盘、调整朝向、支持屏幕旋转 / 方向传感器（DeviceOrientationEvent）或 GPS 补充。操作要流畅。 |
| **功能完整性** | 至少包含 24 山（24方向）、三合／三元／飞星等玄空风水常用环（可选多层环）、八卦／干支等标识。最好能支持定制环或公式。 |
| **移动端适配** | UI 在不同屏幕宽度、横竖屏下都要好看；触控操作要稳定；权限请求清晰（例如访问方向传感 /陀螺仪、GPS 等）。 |
| **性能和兼容性** | 在常见手机里（iOS Safari / Android WebView 等）加载速度快，动画 /旋转不卡顿；库体积适中，能和 Next.js／React／Vue 等集成。 |
| **可定制性与开源许可** | 源代码可获取／修改；LICENSE 明确；如果要加飞星、九宫格等环，结构要容易扩展。 |

---

## 现有开源或接近开源／可借鉴的组件或项目

我查了一下，目前并没有非常完备且专门做“玄空风水罗盘（多环 + 专业风水公式 + 高视觉质量 + 移动端优秀交互）”的开源库（至少没找到那些完全成熟的）。不过下面这些可以作为基础或者组件的一部分，可以借来改造／组合：

1. **compass.js**（joeyklee/compass.js）
 - 是一个非常轻量的 JS 库，用来获取相对于北方（或某方向）的朝向／方向角。
 - 优点：简洁、兼容性好yklee/compass.js: A minimal javascript library for ...](https://github.com/joeyklee/compass.js/?utm_source=chatgpt.com)** · *github.com*
> A minimal javascript library for accessing the compass direction of a user relative to North. - joeyklee/compass.js

 - 优点：简洁、兼容性好，可以在手机上获取方向。
 - 缺点：它只是“指针朝向 /角度”功能，不包含风水罗盘的多层环／刻元素。要做罗盘环、视觉刻度、风水公式，要自己加。

2. **antgiant/compass_3D**
 - 一个用 three.js 实现的 3D 罗盘，支持 HTML5 设备方向、位置等。turn1search23
 - 优点：视觉效果不错、3D 感强，可离线。
 - 缺点：目前功能上看还不够玄空风水专业的环与公式，可能b.com/antgiant/compass_3D?utm_source=chatgpt.com)** · *GitHub*
> A simple HTML5 3D Compass that's offline capable. Makes use of the HTML5 Location, Device Orientation, Screen Orientation, and the amazing three.js library.

 - 优点：视觉效果不错、3D 感强，可离线。
 - 缺点：目前功能上看还不够玄空风水专业的环与公式，可能动画性能 /资源消耗较高，需要优化。

3. **“8directions” 示例项目**（mrant95/8directions）
 - 有一个带有传统风水罗盘覆盖图层（overlay）在地图上的例子。
 - 可借鉴其八方向／八ant95/8directions](https://github.com/mrant95/8directions?utm_source=chatgpt.com)** · *GitHub*
> **Interactive Map**: View the route on Google Maps with optional feng shui compass overlay ## Feng Shui Compass The application features a traditional Chinese feng shui compass (羅盤) with: - **Proper Orientation**: South (南) at top, North (北) at bottom - **8 Directions**: Each with Chinese names and trigram labels - **Trigram Analysis ...

 - 可借鉴其八方向／八卦的刻度 + trigram 标记方案。

4. **“罗盘时钟”类型项目**
 - 比如 “道教之家罗盘时钟” （wulintang/luopan）以及纯 JS 的罗盘样式/钟类项目。
 - 这些设计感可能比较简化／偏装饰性质，可用于基础视觉或动画效果参考。

---

## 建议方案（结合你项目特ulintang/luopan?utm_source=chatgpt.com)** · *GitHub*
> 道教之家罗盘时钟. Contribute to wulintang/luopan development by creating an account on GitHub.

 - 这些设计感可能比较简化／偏装饰性质，可用于基础视觉或动画效果参考。

---

## 建议方案（结合你项目特性定制或替换）

基于你要在一个 AI 八字风水项目里替换现有罗盘，这里是一个推荐做法流程 +技术实现细节建议：

1. **选一个基础库**
比如选 `compass.js` 用来处理方向感 /手机方向传感器 + 三个环／刻度／24山自己绘制 + 指南针针的视觉部分用 SVG／Canvas 或 WebGL/Three.js。如果要 3D 风格，用 `compass_3D` 改造。

2. **用 React + Next.js 封装为组件**
 - 组件接受参数：朝向类型（坐山向门、坐向坐山朝向等）、要显示的环（飞星环、24山、三元／三合环、九宫格等）、主题皮肤（色彩／字体／皮肤图案）、尺寸响应式。
 - 在 React 中用 SVG 或 Canvas 渲染罗盘环 +刻度 +文字 +指针 +动画。支持旋转动画（用 CSS transform 或 requestAnimationFrame）。

3. **集成设备方向 /陀螺仪 /磁场校正**
 - 使用浏览器 DeviceOrientation + ScreenOrientation API；iOS 新版本可能需要用户允许权限。
 - 如果设备方向精度不够，考虑加 GPS /移动方向辅助校正。
 - 提供手动输入角度的备用方案（用户可以手动旋转罗盘或输入度数）。

4. **移动端优化**
 - 触控手势（旋转、拖动、缩放，如果你支持缩放或放大盘面）。
 - 屏幕尺寸小的时候减层数或简化视觉以保证清晰度／不卡顿。
 - 图片 /图标要是矢量或高分辨率。

5. **视觉设计与“高大上”**
 - 选一个统一的主题（例如金属框＋红金色调、仿古纹理背景、水墨风格、甚至带些发光效果）。
 - 渐变阴影／浮雕效果 + 动画过渡（指针摆动、小跳动效果等）
 - 字体用可读性强的中文字体 + 卦符／符号风格要正统（笔画／布局）。

6. **专业环与公式**
 - 飞星（九星）环、八宅／三合三元环、24山环。
 - 根据用户的出生年／时间／地点来计算九宫飞星／玄空飞伏星等，在组件外部或内部模块提供接口，把计算结果供给视觉环。
 - 支持定制环：用户／管理员可以配置哪些环要显示、顺序、文字内容等。

7. **架构 &部署考虑**
 - Next.js + React，可以用动态 import 或按需加载重环视觉资源，以减初始 bundle 的大小。
 - 如果有动画复杂或 3D，用 WebGL 或 Three.js，要做好性能监控和 fallback（如果设备不支持 WebGL）。
 - 前端代码与风水公式模块分离，风水公式逻辑可测试／校正。

---

## 推荐选项（如果我做的话，会选这些作为起点或组合）

下面是我如果要替换你的现有罗盘，会考虑的几个方案，并评估利弊：

| 方案 | 优点 | 难点／要做的事情 |
|---|---|---|
| **用 antgiant/compass_3D 改造** | 视觉效果强，用 three.js 可以做立体感／阴影／动态；用户体验可能“高大上” | three.js 的体积＋性能消耗高；要自己加风水环 +刻度；手机 GPU 性能各异，需要兼容性调优；手势／触控旋转要做得顺滑。 |
| **用 compass.js + 自定义 SVG/Canvas 环** | 简洁可靠，方向感测 +朝向稳定；体积小，集成容易；可在 Next.js + React 中做 SSR/前端渲染 +控制外观。 | 风水环／符号／刻度要你自己画／设计；动画／视觉设计需要美工投入；方向精度可能依赖设备传感器／权限。 |
| **自己从零设计组件（SVG + React + 动画 +传感器 +风水公式）** | 最灵活，可以把功能与视觉都做得正好契合你项目需要；可以控制每一个细节，也可以做皮肤切换、テーマ模式、高分辨率适配等。 | 开销大（时间／设计／调试）；测试要多；如果功能复杂（多个环＋计算公式＋动画＋兼容性），出 bug 的可能性多；要有设计／UI／UX支持。 |

---

## 我的推荐方案

基于你要“专业＋好看＋手机好用”，我个人建议是：

- **组合方案**：以 `compass.js` 或类似轻量方向获取库作为基础，再用 React + SVG/Canvas 自己绘制多层罗盘环 +指针 +风水符号。
- 视觉皮肤可以采用类 “金属 + 磁环 +古风” 的风格，这样既庄重又有质感。
- 如果时间允许，可以做一个“3D 或透视效果”版本作为高级皮肤，但默认版本建议先用 2D SVG + CSS 动画 + Canvas 渐变阴影以保证性能与兼容性。

---

如果你愿意，我可以帮你搜集几个现成开源的罗盘全功能样例／代码仓库（含视觉风水环、飞星、24山等环＋好看的主题），发给你看你选哪个最合适／最接近你现在的风格。要吗？

---
## 🧑‍💻 User

好的，帮我搜集几个现成开源的罗盘全功能样例／代码仓库（含视觉风水环、飞星、24山等环＋好看的主题），发给我看你选哪个最合适／最接近我现在的风格，视觉皮肤可以采用类 “金属 + 磁环 +古风” 的风格，这样既庄重又有质感。

---
## 🤖 Assistant

> search("好的，帮我搜集几个现成开源的罗盘全功能样例／代码仓库（含视觉风水环、飞星、24山等环＋好看的主题），发给我看你选哪个最合适／最接近我现在的风格，视觉皮肤可以采用类 “金属 + 磁环 +古风” 的风格，这样既庄重又有质感。")

我帮你搜了几个开源 /接近开源的罗盘／风水罗盘例子 + 仓库，标注下它们的优缺点，跟“金属＋磁环＋古风”风格的匹配度，以及我觉得哪个最接近你可以直接改／拓展。你可以对比后决定。

---

## 值得考察的开源／实例仓库

| 仓库 / 项目名 | 链接 & 简要描述 | 优点 | 不足／改进空间 | 与“金属＋磁环＋古风”风格匹配度 |
|---|---|---|---|---|
| **GeomanticCompass / FengShuiCompass** by `0x7A7A6572`（Vue + Canvas） | Gitee: *geomantic-compass*（“canvas绘制的风水罗盘 vue组件”） / Github FengShuiCompass罗盘: canvse绘制的风水罗盘 vue组件](https://gitee.com/zzerx/geomantic-compass?utm_source=chatgpt.com)** · *gitee.com*
> About canvse绘制的风水罗盘 vue组件 expand collapse /zzerx/geomantic-compass Vue and 3 more languages Vue 76.4% HTML 18.6% JavaScript 5.0% Releases
/ Github FengShuiCompass | + 可自定义层（每一圈A7A6572/FengShuiCompass: 自定义罗盘](https://github.com/0x7A7A6572/FengShuiCompass?utm_source=chatgpt.com)** · *github.com*
> 自定义罗盘. Contribute to 0x7A7A6572/FengShuiCompass development by creating an account on GitHub.
| + 可自定义层（每一圈 ring）数据、文字、颜色、刻度风格都可以配置。ch4 <br> + 用 Canvas 渲染，性能比较可控，而且适合移动端。<br> + 支持外部控制罗盘旋thub.com/0x7A7A6572/FengShuiCompass?utm_source=chatgpt.com)** · *GitHub*
> 自定义罗盘. Contribute to 0x7A7A6572/FengShuiCompass development by creating an account on GitHub.
<br> + 用 Canvas 渲染，性能比较可控，而且适合移动端。<br> + 支持外部控制罗盘旋转／中心点／大小／层数等。<br> + 有一定社区／人用案例，改造性高。 | − 没看到内置完整飞星／24山环＋八卦环这样的专业公式层（可能要自己添加数据层）。<br> − 视觉皮肤不够“金属质感＋磁环＋古风”的雕刻／材质效果，偏扁平／纯色＋渐变。要改造材质／阴影／细节效果。<br> − 如果要带动画／3D 光照／阴影效果，还要自己做扩展。<br> − License 上有一点不确定：仓库似乎没明确开源许可证文件。使用前要核实。 | **[FengShuiCompass: canvas 自定义罗盘 - Gitee](https://gitee.com/zzerx/FengShuiCompass?utm_source=chatgpt.com)** · *Gitee*
> FengShuiCompass - 自定义罗盘 自定义罗盘数据和样式，基本样式配置，控制罗盘旋转是外部控制。可自定义显示的数据，文字颜色，具体位置填充，文字显示样式等，之前写的，许多结构很陈旧，现在用vue重新封装，并修改了部分逻辑。 开始 概念： 层：一圈的数据为层，下标从0开始。 宫：一层中的一 ...
| ★★★★☆（4/5） —— 很接近你的需求，核心功能＋定制性强，是我目前推荐的首选。视觉材质和装饰还要加。 |
| **masterflywolf/luopan** | GitHub: masterflywolf/luopan — 风水罗盘，带 HTML + JS + CSS 的示例。 | + 已经有多个样式（custom.html, map.html, index /clock://github.com/masterflywolf/luopan?utm_source=chatgpt.com)** · *GitHub*
> 风水罗盘. Contribute to masterflywolf/luopan development by creating an account on GitHub.
| + 已经有多个样式（custom.html, map.html, index /clock etc.）可以看出来功能／样式变体。 <br> + 简单易上手- masterflywolf/luopan: 风水罗盘](https://github.com/masterflywolf/luopan?utm_source=chatgpt.com)** · *GitHub*
> 风水罗盘. Contribute to masterflywolf/luopan development by creating an account on GitHub.
<br> + 简单易上手，对初步替换／demo 展示速度快。<br> + 纯前端 (JS + HTML + CSS)，修改门槛低。 | − 可能功能不够完整，比如飞星、时间／九运／玄空公式环未必全部内建。<br> − 视觉效果偏基础／扁平，没有材质感／细节雕刻／高光／阴影／质感这种“金属＋磁环”那种感觉。<br> − 移动端触控／方向传感器适配可能少或者没有。<br> − 样式重用／定制性可能比上面那个少。 | ★★★☆☆（3/5） —— 用作备选／快速原型不错，但做“高大上”还需要较多设计工作。 |
| **ChaoBaoxiaokun/compass** | GitHub: “风水罗盘”仓库 by ChaoBaoxiaokun。 | + 已有样例，基本罗盘界面 + CSSxiaokun/compass: 风水罗盘](https://github.com/ChaoBaoxiaokun/compass?utm_source=chatgpt.com)** · *GitHub*
> 风水罗盘. Contribute to ChaoBaoxiaokun/compass development by creating an account on GitHub.
| + 已有样例，基本罗盘界面 + CSS + 图片支持。<br> + 很可能看到了一些图像资源 +刻度 +方向标识。<br> + 简单直接，可以快速看效果。 | − 功能可能很基础，没有多层 ring 的专业风水环（飞星、24山、三元／三合环等）<br> − 触控／旋转／方向感应支持未必。<br> − 可定制性／图形材质可能偏简单。<br> − 视觉质感可能不够“古风＋金属＋磁环”。 | ★★☆☆☆（2/5） —— 可以用作视觉参考或简化版本，不是最符合你“专业＋好看”的目标。 |
| **funfwo / Fengshui** | GitHub: `funfwo/Fengshui` 是一个排盘 + 风水解释项目（包括飞星、九宫等） | + 风水算法（飞星、九宫、山向兼向o/Fengshui: Fengshui project that can make model and give ...](https://github.com/funfwo/Fengshui?utm_source=chatgpt.com)** · *GitHub*
> About Fengshui project that can make model and give explanation. 按照玄空飞星法排盘并给出解释。本项目考虑了兼向，山水格局，能给出文昌位、财位、东西四宅等解释，并根据八卦理论给出九宫的山向飞星解释。如需具体了解，请微信fengshuicxt（楚轩亭）。
| + 风水算法（飞星、九宫、山向兼向等）已有实现。对于你项目中的算法部分很有用。<br> + MIT 协议，开源可用。<br> + 虽然不一定有好看的罗盘视觉组件，但算法和数据层可以借来做 ring 层／计算。 | − 没有成熟的视觉罗盘界面／组件，可能只是 CLI 或静态页面／HTML 输出。<br> − 交互 + 动画视觉部分你得自己写。<br> − 美工设计和材质就更少。 | ★★★☆☆ （3/5） —— 算法层非常有用，用作数据源 +结合视觉组件效果会比较强，但还要自己设计界面。 |

---

## 哪个最推荐 +如果选它要做的改动

综合来看，如果是我替你选，我会优先考虑 **GeomanticCompass / FengShuiCompass**（0x7A7A6572） 这个 Vue + Canvas 的那一个。因为它在可定制性 + 层结构 + Canvas 绘图 +能控制旋转 &大小这些基础都不错，跟你的 Next.js／React 的架构比较亲和（虽然是 Vue，可以借鉴思想甚至改写成 React 版）。

### 如果用它，要做哪些提升／改动／定制来符合“金属＋磁环＋古风”的标准：

| 项目 | 建议细节 /可以做的改造 |
|---|---|
| **材质感 / 视觉升级** | 使用金属质感的边框：可以在 Canvas 或用 SVG 外圈加金属边框、高光阴影效果。可以用纹理贴图 +渐变 +内阴影＋外阴影。<br> 加入“磁环”效果：中间针或者指针部分做金属材质 +体现指针转动的动态反光或光泽。<br> 古风纹理背景（比如云纹，雷纹，木纹等），可以让底盘部分带些纹理但不要过度影响刻度清晰度。 |
| **刻度与层环丰富** | 添加专业环，例如：24山环（标注山名＋数字）、飞星环、九宫环、三合／三元环、八卦环等。每层要数据齐全，并支持翻译显示或中英文切换。<br> 支持隐藏／显示层（用户可定制显示哪些环）。 |
| **交互／方向感知** | 用 DeviceOrientation / ScreenOrientation API 获取设备朝向，使罗盘针随手机旋转；支持手动旋转输入角度作为备用。<br> 支持手势（拖动旋转、缩放显示层、放大看细节）。<br> 手机端触控优化：避免滑动误触；响应快；高帧率动画。 |
| **响应式与性能优化** | 初次加载仅加载基础 rings 和指针，延迟加载其他环或高清材质。<br> Canvas 渲染要限制 redraw 次数／节流；在低性能设备上简化视觉效果（如阴影／高细节图案可降级）。<br> 若需要 3D 或真实光照，可考虑 WebGL 或 Three.js，但备用回退为 2D Canvas。 |
| **配色与字体** | 古风字体（笔画粗细／楷体／仿宋／篆书等风格选项）——至少有主题切换；刻字清晰。<br> 金属 +磁环颜色：比如金色、铜色、暗金／古铜＋银灰＋深棕／黑背景衬托。<br> 指针颜色要醒目，但不要破坏整体古典气质。 |
| **细节装饰** | 在指针中心加装饰物（如仿铜轴心、玫瑰花纹、刻花等小纹理）。<br> 在圆盘外或环之间的空白处加古风小图案／纹饰（例如雷纹云纹、变形云形边框等）。<br> 考虑动画效果如指针轻微晃动 /过渡 /刻度跳动但不频繁以免分散注意力。 |

---

## 次选＋备用如果第一个不合适

如果 GeomanticCompass 不满足某些需求（比如你要完全 React + SSR +非常复杂公式 + 3D特效），那么备用我会用 **masterflywolf/luopan** + 算法项目（如 funfwo）组合起来自己做一个组件。或者也可以 fork GeomanticCompass，改写为 React + Next.js 组件。

---

如果你愿意，我可以把这些候选的 repo 用一个表格发给你，并标出“工作量估算”、“匹配度评分”、“改造成本”，你看哪个最划算／适合你直接拿来用／稍微修改。要我做这个么？

---
## 🧑‍💻 User

好的，把这些候选的 repo 用一个表格发给我，并标出“AI修改代码的工作量估算”、“匹配度评分”、“改造成本”，我看哪个最划算／适合我直接拿来用／稍微修改

---
## 🤖 Assistant

好的，下面是我为你整理的候选开源风水罗盘库的表格，包含了“AI修改代码的工作量估算”、“匹配度评分”和“改造成本”的相关信息。你可以参考这些信息，选择最适合你需求的方案。

| 仓库 / 项目名 | 链接 | 功能简介 | AI 修改代码的工作量估算 | 匹配度评分 | 改造成本 | 适合场景 |
|---|---|---|---|---|---|---|
| **GeomanticCompass / FengShuiCompass** by `0x7A7A6572` | [Gitee: FengShuiCompass](https://gitee.com/zzerx/geomantic-compass?utm_source=chatgpt.com) / [GitHub: FengShuiCompass](https://github.com/0x7A7A6572/FengShuiCompass?utm_source=chatgpt.com) | 基于 Vue 和 Canvas 的风水罗盘，支持自定义层数据、旋转控制、外部接口。 | **工作量：中**<br> 修改为 React 版，优化样式和层次结构，加入飞星、24山等环。 | **匹配度：★★★★☆ (4/5)** | **改造成本：中**<br> 主要是修改材质、视觉效果、添加环层、改为 React 组件。 | 高定制性、符合需求，适合替换现有的罗盘，稍作修改可加入更多风水环。 |
| **masterflywolf/luopan** | [GitHub: masterflywolf/luopan](https://github.com/masterflywolf/luopan?utm_source=chatgpt.com) | 简单风水罗盘，包含多个样式，纯前端实现，适合快速原型展示。 | **工作量：低**<br> 调整为 React 组件，改进视觉效果，添加更多环层和数据。 | **匹配度：★★★☆☆ (3/5)** | **改造成本：低**<br> 简单的视觉优化和功能扩展，可能需要重构部分逻辑。 | 快速原型开发，适合小规模展示，若需要高大上的效果需要较多设计和改动。 |
| **ChaoBaoxiaokun/compass** | [GitHub: ChaoBaoxiaokun/compass](https://github.com/ChaoBaoxiaokun/compass?utm_source=chatgpt.com) | 风水罗盘，基本的 CSS 和图片支持，界面简单。 | **工作量：低**<br> 视觉和功能上的修改较为简单，主要是加上飞星和24山环。 | **匹配度：★★☆☆☆ (2/5)** | **改造成本：低**<br> 需要增加更多环、完善交互、优化视觉效果。 | 适合小项目或作为基础参考，不适合要求高的“金属＋古风”风格。 |
| **funfwo/Fengshui** | [GitHub: funfwo/Fengshui](https://github.com/funfwo/Fengshui?utm_source=chatgpt.com) | 风水排盘与算法项目，包含飞星、九宫等。 | **工作量：高**<br> 没有现成的视觉罗盘，需要结合其他项目实现，构建完整的 UI 和交互。 | **匹配度：★★★☆☆ (3/5)** | **改造成本：高**<br> 需要整合算法和视觉层，UI/UX 和动画的设计需要较大投入。 | 适合需要自定义风水算法和界面的用户，但不包含完整的视觉组件。 |
| **compass.js** | [GitHub: compass.js](https://github.com/joeyklee/compass.js?utm_source=chatgpt.com) | 轻量级 JS 库，用于方向传感器的数据获取。 | **工作量：中**<br> 需要自定义罗盘样式和环层，添加风水功能。 | **匹配度：★★★☆☆ (3/5)** | **改造成本：中**<br> 需要大量自定义 CSS/Canvas 部分来实现完整的风水罗盘。 | 适合想要快速实现方向获取的项目，但需要较多自定义才能做成完整风水罗盘。 |

---

### 评分与推荐分析：

1. **GeomanticCompass / FengShuiCompass**:
 - **工作量：中**，这是目前最接近你需求的项目，已经有了基本的 Canvas 渲染和自定义功能，主要需要将其转化为 React 组件，添加更多的风水环（如飞星、24山、九宫等）并优化视觉效果。虽然基于 Vue，但修改起来相对容易。
 - **匹配度：★★★★☆**，它能满足你对“金属＋磁环＋古风”风格的部分需求，只需要增加材质感和细节，符合你的高端需求。
 - **改造成本：中**，主要是在视觉和功能上进行增强，尤其是风水层和风格化设计。

2. **masterflywolf/luopan**:
 - **工作量：低**，这个仓库提供了一个简单的示例，适合快速实现，但功能较为基础，适合做一个快速原型。
 - **匹配度：★★★☆☆**，它的视觉效果和功能较为简单，不符合“金属＋古风”高端需求，需要较多的设计工作。
 - **改造成本：低**，主要是对视觉效果进行改善和扩展功能，适合做小型项目或试验。

3. **ChaoBaoxiaokun/compass**:
 - **工作量：低**，这是一个最基础的风水罗盘，适合初步尝试，但功能和视觉设计都需要大量改进。
 - **匹配度：★★☆☆☆**，它的设计比较基础，不适合做高端的“金属＋古风”风格。
 - **改造成本：低**，可以用作基础参考，简单修改后可以用于较小的项目。

4. **funfwo/Fengshui**:
 - **工作量：高**，这个项目专注于风水算法，但没有现成的视觉罗盘，整合起来需要大量开发。
 - **匹配度：★★★☆☆**，如果你需要高度自定义的风水分析和排盘，这个项目的数据层非常有价值，但视觉组件需要完全重新设计。
 - **改造成本：高**，整合风水算法和创建自定义的 UI、动画、风水环将需要较多的工作。

5. **compass.js**:
 - **工作量：中**，作为一个简单的方向获取库，功能上较为基础，适合做一些简单的罗盘功能，但要加入风水环和自定义内容需要大量修改。
 - **匹配度：★★★☆☆**，它的核心功能是方向感应，但缺少风水环的支持。
 - **改造成本：中**，需要大量的前端定制和功能扩展才能达到你需要的效果。

---

### 总结推荐：
如果你希望获得一个较为完备的解决方案，并且能够快速上手和修改，我**强烈推荐选择** **GeomanticCompass / FengShuiCompass**，它的基础功能已经具备，只需要转化为 React 组件并增强视觉效果和风水环功能，改造成本适中，能够满足高大上的设计要求。

如果你只需要一个简单原型或者快速展示，那么 **masterflywolf/luopan** 或 **ChaoBaoxiaokun/compass** 也是不错的选择，但这两个项目在功能和视觉上都需要较大的改进。

---

希望这个表格和分析能帮你做出更明智的决策！如果你有任何进一步的疑问或需要帮助实现某个特定功能，随时告诉我！

---
## 🧑‍💻 User

我看到这个仓库了，网址是https://github.com/0x7A7A6572/FengShuiCompass，你觉得我应该如何改造才能和我的qiflow项目完美匹配呢，你告诉我具体步骤，或者帮我写个产品功能需求

---
## 🤖 Assistant

```
{"search_query": [{"q": "0x7A7A6572 FengShuiCompass GitHub"}, {"q": "geomantic-compass gitee 0x7A7A6572"}, {"q": "FengShuiCompass canvas \u7cbe\u795e \u7ea2 0x7A7A6572"}, {"q": "masterflywolf luopan GitHub"}], "response_length": "short"}
```

> *Thought for 17s*

太好了，就用你给的这个仓库作为基座来“定制到完全贴合 QiFlow（Next.js）”。我把改造思路拆成两部分：**一步步落地的技术改造清单** + **可直接拿去评审/排期的 PRD（产品需求文档）**。关键点会引用仓库现状（可自定义层、外部控制旋转、Canvas 渲染等）以确保方案可行。citeurnearchurnearchurnearch> **[GitHub - 0x7A7A6572/FengShuiCompass: 自定义罗盘](https://github.com/0x7A7A6572/FengShuiCompass?utm_source=chatgpt.com)** · *GitHub*
> 自定义罗盘. Contribute to 0x7A7A6572/FengShuiCompass development by creating an account on GitHub.


---

# 一、技术改造清单（从仓库到 QiFlow 组件的落地路线）

> 目标：在不破坏原有“可自定义层 + 外部控制 + Canvas 绘制”优势的前提下，封装为 **React/Next.js 组件**，并补齐玄空所需环层、手机传感器、金属古风皮肤、性能与无障碍。

## 0）许可与版本基线
- **检查 LICENSE**：Gitee 显示“未声明开源许可证”，GitHub 也未见明确 LICENSE。务必在使用前与作者确认授权，或仅作学习参考/内部使用，避免商用风险。citeurnearch> **[FengShuiCompass: canvas 自定义罗盘 - Gitee](https://gitee.com/zzerx/FengShuiCompass?utm_source=chatgpt.com)** · *Gitee*
> FengShuiCompass - 自定义罗盘 自定义罗盘数据和样式，基本样式配置，控制罗盘旋转是外部控制。可自定义显示的数据，文字颜色，具体位置填充，文字显示样式等，之前写的，许多结构很陈旧，现在用vue重新封装，并修改了部分逻辑。 开始 概念： 层：一圈的数据为层，下标从0开始。 宫：一层中的一 ...

- **固定基线 commit**：挑选一个稳定提交做为 fork 基线，便于后续维护/回滚。citeurnearch> **[GitHub - 0x7A7A6572/FengShuiCompass: 自定义罗盘](https://github.com/0x7A7A6572/FengShuiCompass?utm_source=chatgpt.com)** · *GitHub*
> 自定义罗盘. Contribute to 0x7A7A6572/FengShuiCompass development by creating an account on GitHub.


## 1）从 Vue/裸 JS 到 React 组件（Next.js 兼容）
- **方式 A：轻改造封装**
保留原 `FengShuiCompass` 的绘制类（Canvas API），在 React 中用 `useRef` 提供 `canvas`，在 `useEffect` 中执行 `.setCenterPoint().setRadius()... .setCompassData().draw(ctx)` 的**链式调用**，并把旋转角/主题/显示层当作 props。仓库文档里强调“外部控制旋转”和“先 set 再 draw”的链式使用方式，我们直接复用。citeurnearchurnearch> **[FengShuiCompass: canvas 自定义罗盘 - Gitee](https://gitee.com/zzerx/FengShuiCompass?utm_source=chatgpt.com)** · *Gitee*
> FengShuiCompass - 自定义罗盘 自定义罗盘数据和样式，基本样式配置，控制罗盘旋转是外部控制。可自定义显示的数据，文字颜色，具体位置填充，文字显示样式等，之前写的，许多结构很陈旧，现在用vue重新封装，并修改了部分逻辑。 开始 概念： 层：一圈的数据为层，下标从0开始。 宫：一层中的一 ...

- **方式 B：数据/渲染解耦**
若后续希望 SVG/Three.js 皮肤共存，可把“层数据与布局计算”抽成纯函数，把“渲染器”做成 **CanvasRenderer / SVGRenderer** 的可插拔接口。

## 2）新增/完善专业环层（玄空 + 传统）
- **24山环**（子、癸、丑…）：度数区间、方位名、汉字标注、序号（兼容 8/24/72 刻度）。
- **玄空飞星环**：支持三元九运（当前九运为**第九运：2024–2043**），坐向/来龙/时间维度输入 → 计算山星/向星/运星；支持“替卦”“挨星”算法结果动态映射到环层。
- **八卦/后天八卦环**、**天干地支环**、**纳甲/三合/三会**可选显示。
- **“层定义 JSON”**：遵循仓库的“每一圈为一层（layer），每层含若干宫（cell）”约定，字段包括：`name/startAngle/font/textColor/vertical/data[...]` 等，确保与原数据结构兼容（仓库文档中有层/宫的概念与示例）。citeurnearch> **[FengShuiCompass: canvas 自定义罗盘 - Gitee](https://gitee.com/zzerx/FengShuiCompass?utm_source=chatgpt.com)** · *Gitee*
> FengShuiCompass - 自定义罗盘 自定义罗盘数据和样式，基本样式配置，控制罗盘旋转是外部控制。可自定义显示的数据，文字颜色，具体位置填充，文字显示样式等，之前写的，许多结构很陈旧，现在用vue重新封装，并修改了部分逻辑。 开始 概念： 层：一圈的数据为层，下标从0开始。 宫：一层中的一 ...


## 3）设备方向与移动优化
- **DeviceOrientation 接入**：在用户授权后读取 `alpha`/`beta`/`gamma`，并做**软滤波**（一次指数平滑 + 节流）以避免跳动。
- **校准与回退**：iOS 方向权限弹窗；指南针易受磁场干扰，提供“手动输入度数/滑盘旋转”回退。
- **触控手势**：单指旋转、双指缩放（若支持局部放大）；禁用页面滚动穿透。
- **横竖屏**：保持刻度清晰与点击命中区稳定。

## 4）主题与视觉皮肤（“金属 + 磁环 + 古风”）
- **主题系统**：`theme = 'metal

---
## 🧑‍💻 User

继续

---
## 🤖 Assistant

继续我们上面的改造方案，接下来我会详细列出如何为你的项目设计和实现**“金属 + 磁环 + 古风”**视觉皮肤，并提供一个完整的产品需求文档（PRD）供你参考。

---

## 4）主题与视觉皮肤（“金属 + 磁环 + 古风”）
为了实现**金属 + 磁环 + 古风**的视觉效果，以下是几个具体的实施步骤：

### **A. 皮肤与视觉元素设计**
1. **金属质感**：
 - 使用 **渐变** 与 **高光阴影** 来模拟金属的反射效果，特别是在外圈和指针部分。
 - 可以通过 **CSS3 渐变** 或 **Canvas 绘制** 结合金属纹理来实现金属感（如金色、铜色、银色等）。
 - 对于外圈的刻度线，加入**渐变金属色**，利用 **CSS的 `box-shadow` 和 `text-shadow`** 来增强立体感。

2. **磁环设计**：
 - 中心指针需要有一种**磁性指向感**，可以设计成金属的光泽感，利用**光影变化**来展示磁场的指引。增加**动态效果**，例如指针在旋转时有微弱的反光或阴影变化。
 - 采用 **SVG** 或 **Canvas** 来渲染精细的磁环纹理，结合 **WebGL** 使其在旋转时表现出高光效果。

3. **古风设计**：
 - 底盘背景采用**中国传统纹理**，如云纹、雷纹或竹纹等，以带来古典气质。通过 **SVG/Canvas 绘制** 或使用背景图来实现。
 - 刻度的字体使用**古风书法字体**（如楷体、隶书、宋体等），并配以清晰的**颜色对比**（例如金色文字和深色背景）。

4. **细节装饰**：
 - 在指针和环的连接处加入**浮雕效果**或**镶嵌效果**，增加细节层次感。
 - 可以设计一些象征性的小图标（如“龙虎、八卦、风水符号”）在不同层环中，进一步提升古风氛围。

### **B. 动画效果与交互优化**
1. **旋转与动画效果**：
 - 指针旋转时，加入 **渐变动画**，在方向变化时动态地显示不同的金属反光效果。
 - 旋转时添加 **微震效果**，模拟磁场干扰的效果（微小的跳动或晃动）。
 - 使用 **CSS 动画** 或 **JavaScript 动画** 实现流畅的旋转效果，并尽量减少性能开销，保持流畅。

2. **响应式与适配**：
 - 使其适应 **不同分辨率的屏幕**，包括 **iPhone、Android 手机、平板** 等。
 - 通过 CSS 和 `media queries` 保证视觉效果在各种设备上都表现良好。

---

## 5）测试与性能优化
1. **性能优化**：
 - **节流与防抖**：由于手机方向传感器数据波动大，可以在获取 `alpha`/`beta`/`gamma` 时，应用节流/防抖技术，避免每次变化都触发动画更新。
 - **图形渲染优化**：确保 Canvas 渲染过程中，采用 **requestAnimationFrame** 来保证动画帧率稳定，避免造成过高的 CPU 使用。

2. **兼容性与移动端适配**：
 - **适配不同设备**，特别是老旧手机和低配设备，保证基本的交互和渲染效果。
 - 使用 **媒体查询** 或 **React-responsive** 来调整不同分辨率下的布局，确保手机竖屏与横屏时均能良好显示。

---

# 二、产品功能需求文档（PRD）

**产品名称**：QiFlow AI 风水罗盘

**功能目标**：构建一个能够显示八卦、飞星、24山等风水环的罗盘，并以“金属 + 磁环 + 古风”视觉设计呈现，为用户提供精准的风水分析，帮助用户更好地理解风水布局和命理走势。

## **功能模块**

### **1. 主页界面**
- **展示风水罗盘**：展示动态旋转的风水罗盘，支持用户通过设备方向传感器或手动调整。
- **选择功能模块**：展示八字分析、飞星布局、24山等功能选项。
- **导航菜单**：提供首页、设置、帮助文档等导航链接。

### **2. 风水罗盘功能**
- **罗盘指针旋转**：根据设备方向（通过 `DeviceOrientation` 获取数据）或手动旋转，指针与环层同步旋转。
- **支持多个风水层显示**：
 - **飞星环**：根据用户的八字与居住地点信息，动态计算并显示飞星位置与相关吉凶。
 - **24山环**：显示坐山向门的24方位，标明相应的山星和方位。
 - **八卦/干支环**：显示传统八卦与天干地支信息，用户可根据需要选择显示。
- **环层自定义**：支持用户定制显示的环层，如是否显示飞星、24山等，环层的颜色、字体、大小等。
- **交互控制**：用户可以通过滑动、触控旋转调整罗盘指针，查看不同方位的信息。

### **3. 风水配置与显示**
- **用户输入**：允许用户输入出生日期、时间、地点等信息，计算并展示其命理及风水布局。
- **风水计算**：通过八字算法、飞星算法、三合三元等风水公式计算用户的命运、风水、吉凶等信息。
- **输出展示**：根据计算结果展示风水分析，配合罗盘的不同环层，实时更新显示。

### **4. 视觉与主题定制**
- **金属质感与古风主题**：实现“金属+磁环+古风”的视觉效果，包含金属感的外圈、指针、环层，背景使用中国传统的纹理装饰。
- **细节装饰与动态效果**：指针和环层动态渲染反光效果，用户可以感受到“磁环”效果。
- **多主题切换**：用户可选择不同的视觉风格，例如古风、金属风、现代简约风等，来定制个人喜好的风水罗盘。

### **5. 移动端与设备适配**
- **响应式设计**：确保不同设备上，特别是在手机、平板上的流畅体验，适配竖屏与横屏。
- **设备方向传感器**：通过方向传感器实时获取设备角度，自动调整罗盘指针的位置。
- **手动旋转**：允许用户通过拖动或输入角度手动旋转罗盘，获取风水布局。

---

## **非功能需求**
- **性能要求**：
 - 应该在现代手机上保持流畅的动画效果和交互，特别是罗盘的旋转和风水环的展示。
 - 提供简单的加载提示，避免因复杂的风水计算或渲染造成应用卡顿。

- **兼容性要求**：
 - 支持主流浏览器（Chrome、Safari、Edge等），以及常见的手机操作系统（iOS、Android）。

- **安全与隐私**：
 - 用户输入的出生日期、时间、地点等信息仅用于风水分析，不外泄，确保数据安全。

---

# 三、开发计划
1. **阶段一：功能开发（2-3周）**：
 - 实现罗盘基本功能：旋转、风水层显示。
 - 完成飞星、24山、八卦等风水环层的自定义及显示。

2. **阶段二：视觉与交互优化（2-3周）**：
 - 金属与古风主题的视觉设计及实现。
 - 完成动画效果、手势交互等功能。

3. **阶段三：性能优化与测试（1周）**：
 - 性能调优，确保流畅的动画体验。
 - 测试在移动设备上的兼容性，确保方向传感器功能正常。

4. **阶段四：上线与推广（1周）**：
 - 部署应用，进行最终的用户体验测试与上线推广。

---

希望这个产品需求文档（PRD）和技术改造清单能帮助你顺利推进项目。如果需要进一步详细的开发支持或代码实现，随时告诉我！

---
## 🧑‍💻 User

如果我使用codex来开发这个罗盘的话，我具体应该怎么操作呢，比如用什么提示词，什么步骤，什么设置，提供什么文件等等

---
## 🤖 Assistant

> **Outlining actionable steps**
> We need to give concrete steps, but since OpenAI Codex is deprecated, I’ll focus on providing actionable workflows, prompts, repo structure, and test cases. I can offer templates, system prompts, and scaffolding for tasks like translating Vue to React. I’ll mention privacy and licensing too, and include some sample data and code snippets. I’ll also suggest tools like VS Code and GitHub Copilot.>

> **Clarifying solution steps**
> Since they asked for "Codex," I can provide prompting patterns like
> *Thought for 21s*

太好了！下面给你一套**“像用 Codex 一样驱动开发”的完整作业流**：包含建议的**设置**、**步骤拆解**、**黄金提示词模板**、**要提供给模型的文件与上下文**、以及**验收与回归测试清单**。你可以直接照着跑一遍，把 Vue 版仓库快速改造成 **Next.js / React 的“金属＋磁环＋古风”玄空罗盘组件**。

---

# 一、环境与设置（Codex/代码助手通用）
> 无论你用 Codex、Cursor、Copilot Chat、或别的 LLM 代码助手，遵循下列设置都能显著提升命中率。

1) **会话角色（System / Instruction）**
- 设定为：
 - “你是资深前端（Next.js + React + Canvas/SVG/WebGL）与中国玄学专家（玄空飞星、24山、八卦）。你将把 Vue/Canvas 罗盘仓库重构为 React 组件，并补齐玄空环、设备方向、移动端交互与主题系统。输出代码需 TypeScript、ESLint/Prettier 规范、JSDoc 注释、无 any、具备单元测试。”

2) **上下文窗口**
- 将**关键文件**、**核心数据结构**、**目标 API 设计**作为“可引用片段”提供给模型（下面有清单）。
- 分阶段喂文件（每次 ≤ 200–400 行），让模型更稳。

3) **输出风格**
- 要求：**先给目录/接口草图，再给代码块**；每个函数前给简短设计说明；所有常量/配置从 `constants/` 或 `theme/` 导出；重要算法写单测。

---

# 二、总体路线图（8 个小里程碑）
1. **搭架子**：新建 `apps/qiflow-web`（Next.js 15 + App Router + TS）或在原项目新增 `packages/luopan`.
2. **最小组件**：把仓库里的 Canvas 绘制逻辑抽象为 `renderLayer(layer, ctx, layout)`；用 `<canvas ref>` 在 React 中渲染静态环（无旋转）。
3. **数据模型**：定义 `Layer`, `Cell`, `Theme`, `CompassOptions` 类型；导入**24山、八卦、干支**等基础数据（JSON）。
4. **交互与旋转**：实现外部角度控制 + 触控旋转；加入 DeviceOrientation（含权限、节流与校准）。
5. **玄空飞星**：实现九运/山星/向星计算模块（纯函数 `computeFlyingStars(params)`），将结果映射到环。
6. **主题系统**：落地“金属＋磁环＋古风”视觉（渐变、高光、阴影、纹理）；支持皮肤切换。
7. **移动端优化**：高 DPI、Retina、局部放大、性能节流、横竖屏适配。
8. **测试与打包**：Playwright 视觉回归、Vitest 单测、Storybook 文档、打包出独立 NPM 包供 QiFlow 复用。

---

# 三、黄金提示词模板（拿去即用）

### 模板 A：**代码迁移 / 抽象**
> **指令：**
> 我将把 Vue/Canvas 风水罗盘迁移为 React/Next.js 组件。请基于以下目标 API，输出目录结构、核心类型定义、最小可运行组件与渲染管线。
> **目标 API：**
>```ts
> export type Layer = { id: string; name: string; ringWidth: number; startAngle: number; clockwise: boolean; cells: Cell[]; style?: LayerStyle };
> export type Cell = { label: string; startDeg: number; endDeg: number; meta?: Record<string, unknown> };
> export type CompassOptions = { radius: number; angle: number; dpiScale?: number; layers: Layer[]; theme: Theme; interactive?: boolean };
> export interface Theme { palette: { bg: string; ring: string; text: string; accent: string }; effects: { metal: boolean; glow: boolean; bevel: boolean } }
> ```
> **请产出：**  
> 1) `packages/luopan-react/` 目录树；2) `Luopan.tsx` 最小实现（仅静态环，TypeScript）；3) `renderers/canvasRenderer.ts` 渲染协议；4) `constants/baseLayers.ts` 示例数据（后天八卦 + 24山轮廓）；5) 说明每个文件的职责与后续扩展点。

---

### 模板 B：**交互与设备方向**
> **指令：**  
> 在 `Luopan.tsx` 中加入：  
> 1) 触控旋转（单指旋转，带阻尼）；  
> 2) `useDeviceOrientation` Hook（iOS 权限、指数平滑、节流到 30Hz）；  
> 3) 外部受控 `angle` 与内部非受控模式切换；  
> 4) DPR 自适应（Retina）；  
> 请给出完整 TS 代码，并解释关键计算（屏幕坐标 → 角度）。

---

### 模板 C：**玄空飞星计算**
> **指令：**  
> 新增 `packages/luopan-core/flyingStars.ts`：  
> - 输入：`{period: 9|8|..., year: number, facingDeg: number, sittingDeg: number, date: string}`  
> - 输出：九宫格 3×3 的 `{mountain:number, facing:number, annual:number, monthly:number}`；  
> - 实现 “替卦/挨星” 与九运（默认 2024–2043 为九运）；  
> - 给出 3 组单测样例（Vitest）。  
> 同时新增 `layers/flyingStarLayer.ts` 将九宫结果映射到罗盘环（或九宫叠加）。

---

### 模板 D：**金属＋古风主题**
> **指令：**  
> 生成 `theme/metalAncient.ts`：  
> - 金属外圈（径向渐变 + 高光 + 内阴影）；  
> - 指针中心“磁环”高光动画（CSS 或 Canvas 动态高光）；  
> - 古风纹理（云纹/雷纹）做弱透明背景；  
> - 24山与八卦的配色对比清晰；  
> 输出 TS 代码 + 渲染前后对比截图（在 Storybook 中说明怎么启用）。

---

### 模板 E：**Storybook + 视觉回归**
> **指令：**  
> 配置 Storybook：  
> - 故事：基础罗盘、仅24山、飞星+24山、设备方向模拟、主题切换；  
> - 集成 Playwright 截图基线，提交 `__snapshots__`；  
> - 给 `README.md` 写用法：在 Next.js 页面中引入组件 + SSR 注意事项（仅在 CSR 渲染 canvas）。

---

### 模板 F：**集成到 QiFlow**
> **指令：**  
> 将组件以 NPM 包方式供 `apps/qiflow-web` 使用：  
> - 导出 `Luopan`、`useDeviceOrientation`、`computeFlyingStars`；  
> - Next.js 页面示例 `/fengshui/compass`；  
> - SEO/性能：动态 import、关闭 SSR、分离核心算法到 Web Worker（可选）；  
> 输出安装与示例代码。

---

# 四、一次性要喂给模型/助手的**关键文件与素材**

1) **原仓库片段**（分批给）  
   - 绘制/环数据结构（体现“层/宫”的概念）  
   - 旋转/外部控制调用点  
   - 任意自定义层的配置示例

2) **数据常量（你提供或我帮你整理）**  
   - `constants/24mountains.json`（每山起止度数、序号、中文名）  
   - `constants/bagua.json`（后天八卦、卦名、方位度数）  
   - `constants/stemsBranches.json`（天干地支对应度数/方位）

3) **视觉素材**  
   - 古风纹理小图（云纹/雷纹 PNG/SVG）  
   - 金属拉丝/铜质纹理（小而精，注意版权）  
   - 字体（思源宋体/楷体或可商用古风字体）

4) **目标接口草案（上面的 API 定义）**

5) **验收用的坐向/样例**  
   - 3 套样本：坐北朝南/坐西朝东等 + 日期（检验飞星）

---

# 五、建议的项目结构（复制即用）
```
packages/
luopan-core/
 src/
 types.ts
 constants/
 24mountains.ts
 bagua.ts
 stemsBranches.ts
 flyingStars.ts
 index.ts
 tests/
 flyingStars.spec.ts
luopan-react/
 src/
 Luopan.tsx
 hooks/useDeviceOrientation.ts
 renderers/canvasRenderer.ts
 layers/
 baseLayers.ts
 flyingStarLayer.ts
 theme/
 metalAncient.ts
 modernMinimal.ts
 utils/
 geometry.ts
 dpr.ts
 stories/
 Luopan.stories.tsx
apps/
qiflow-web/
 app/fengshui/compass/page.tsx
 components/...
```

---

# 六、示例任务卡（逐步喂给模型）

**Task 1：最小可运行版**
目标：渲染“底盘 + 24山文字环”，无旋转。
产物：`Luopan.tsx`、`baseLayers.ts`、`canvasRenderer.ts`

**Task 2：旋转与手势**
目标：受控 `angle` + 手势旋转 + DPR 适配。
产物：`hooks/useDragRotate.ts`、集成到 `Luopan.tsx`

**Task 3：设备方向**
目标：权限弹窗、指数平滑、节流、回退到手动旋转。
产物：`useDeviceOrientation.ts` + Demo

**Task 4：玄空飞星**
目标：给飞星计算与环映射，3 组单测通过。
产物：`flyingStars.ts`、`flyingStarLayer.ts`、`*.spec.ts`

**Task 5：主题**
目标：metalAncient 主题、指针高光动画、纹理背景。
产物：`theme/metalAncient.ts`、Storybook 故事

**Task 6：移动端优化**
目标：帧率 ≥ 50fps，交互顺滑；横竖屏适配。
产物：节流/缓存、布局修正

**Task 7：集成到 QiFlow**
目标：Next.js 页面演示、动态 import、树摇优化。
产物：`page.tsx` 示例 + README

---

# 七、你可以直接给模型的**示例对话**（复制粘贴即可）

**提示 1：喂数据并生成最小组件**
> 下面是 24 山数据与目标 API。请生成 `packages/luopan-react/src/Luopan.tsx` 与 `canvasRenderer.ts` 的最小实现，只渲染底盘与 24 山标签。要求 TypeScript、无 any、支持 `angle` 受控属性、`dpiScale`，并解释关键几何计算。

**提示 2：加入手势**
> 在 `Luopan.tsx` 基础上加入“单指旋转”：按触摸点相对圆心的极角计算增量角，带阻尼（0.92），并在 `onChange(angle)` 中抛出最新值。请给出完整 TS 代码。

**提示 3：设备方向**
> 实现 `useDeviceOrientation`：iOS 权限、指数平滑（alpha=0.12）、节流至 30Hz、heading 偏移可配置；并更新 `Luopan.tsx` 的“自动跟随设备方向”模式。

**提示 4：飞星算法与映射**
> 编写 `flyingStars.ts` 与单测：给 3 组 (period, facingDeg, date) 样例；输出九宫 `{mountain, facing, annual, monthly}`。然后实现 `flyingStarLayer.ts`，把九宫结果渲染为罗盘上的一环（或中心九宫格）。

**提示 5：金属＋古风主题**
> 生成 `metalAncient.ts`：外圈金属拉丝渐变、内阴影、指针中心磁环高光动画；文字对比度优化；请输出完整 TS 主题与在 `Luopan.tsx` 中的应用方式。

**提示 6：集成 QiFlow**
> 在 `apps/qiflow-web/app/fengshui/compass/page.tsx` 写一个示例页：CSR 渲染 `<Luopan>`，可切换主题、切换“设备方向/手动旋转”，设置坐向并实时显示飞星结果。

---

# 八、验收标准（Definition of Done）

- **功能**：24 山/八卦环渲染；旋转（手势+受控）；设备方向；飞星计算；主题切换。
- **视觉**：默认 metalAncient 主题具备金属高光/内阴影/古风纹理与“磁环”动态高光。
- **性能**：移动端 ≥ 50fps；旋转/方向跟随无明显抖动（平滑算法生效）。
- **工程**：TypeScript 严格、ESLint 通过、Vitest/Playwright 通过、Storybook 可视化用例齐全。
- **可复用**：以包形式导出（`luopan-core` / `luopan-react`），QiFlow 可直接依赖。

---

# 九、你需要准备/提供的文件清单（首批）

- `constants/24mountains.ts`、`bagua.ts`、`stemsBranches.ts`（我可以帮你生成标准化 JSON/TS 常量）
- 古风纹理小图（PNG/SVG）、金属纹理（免版权）
- 字体（可商用许可）
- 三组样例（坐/向/日期）用于飞星验收
- 原仓库中“层/宫”定义与绘制核心代码片段（迁移时参考）

---

要不要我**先帮你生成**：
1) `constants/24mountains.ts` 与 `bagua.ts` 的标准化 TypeScript 常量；
2) `Luopan.tsx` 的最小可运行版本（含受控 `angle` 与 DPR 适配）；
3) `useDeviceOrientation` Hook 的骨架？

你点个头，我就把这三样直接给你落出来。

---
## 🧑‍💻 User

好的

---
## 🤖 Assistant

> **Planning code creation**
> I need to create code for several files, including some constants like 24mountains.ts and bagua.ts, along with hooks, like useDeviceOrientation
> *Thought for 21s*


```json
{"name":"QiFlow Luopan Starter (React/TS) — 最小可运行版 + 常量 + Hook","type":"code/react","content":"// =========================================\n// File: packages/luopan-core/src/types.ts\n// =========================================\nexport type Degree = number; // [0, 360)\n\nexport interface Cell {\n label: string;\n startDeg: Degree; // inclusive\n endDeg: Degree; // exclusive\n meta?: Record<string, unknown>;\n}\n\nexport interface LayerStyle {\n ringFill?: string;\n ringStroke?: string;\n textFill?: string;\n font?: string; // e.g., \"600 12px 'Noto Serif SC'\"\n}\n\nexport interface Layer {\n id: string;\n name: string;\n ringWidth: number; // px in canvas space (before DPR scale)\n startAngle?: Degree; // default 0\n clockwise?: boolean; // default true\n cells: Cell[];\n style?: LayerStyle;\n}\n\nexport interface Theme {\n palette: { bg: string; ring: string; text: string; accent: string };\n effects: { metal: boolean; glow: boolean; bevel: boolean };\n}\n\nexport interface CompassOptions {\n radius: number; // logical px (before DPR)\n angle: Degree; // rotation angle in degrees\n dpiScale?: number; // devicePixelRatio override\n layers: Layer[];\n theme: Theme;\n interactive?: boolean;\n}\n\nexport type Point = { x: number; y: number };\n\nexport const clampDeg = (deg: number): Degree => ((deg % 360) + 360) % 360;\n\n// =========================================\n// File: packages/luopan-core/src/constants/24mountains.ts\n// NOTE: 简化版 24 山数据（每山 15°），真实项目可细化到度分秒\n// 北起子位（0°），顺时针：子、癸、丑、艮、寅、甲、卯、乙、辰、巽、巳、丙、午、丁、未、坤、申、庚、酉、辛、戌、乾、亥、壬\n// =========================================\nimport type { Cell } from \"../types\";\n\nconst NAMES = [\n \"子\",\"癸\",\"丑\",\"艮\",\"寅\",\"甲\",\"卯\",\"乙\",\"辰\",\"巽\",\"巳\",\"丙\",\n \"午\",\"丁\",\"未\",\"坤\",\"申\",\"庚\",\"酉\",\"辛\",\"戌\",\"乾\",\"亥\",\"壬\"\n];\n\nexport const MOUNTAIN_24: Cell[] = NAMES.map((label, i) => ({\n label,\n startDeg: (i * 15) % 360,\n endDeg: ((i + 1) * 15) % 360 === 0 ? 360 : ((i + 1) * 15) % 360,\n meta: { index: i }\n}));\n\n// =========================================\n// File: packages/luopan-core/src/constants/bagua.ts\n// 后天八卦对应主方位（简化中心角与覆盖角度 45°）\n// =========================================\nimport type { Cell } from \"../types\";\n\nexport const BAGUA_POSTERIOR: Cell[] = [\n { label: \"坎\", startDeg: 337.5, endDeg: 22.5, meta: { trigram: \"☵\", dir: \"北\" } },\n { label: \"艮\", startDeg: 22.5, endDeg: 67.5, meta: { trigram: \"☶\", dir: \"东北\" } },\n { label: \"震\", startDeg: 67.5, endDeg: 112.5, meta: { trigram: \"☳\", dir: \"东\" } },\n { label: \"巽\", startDeg: 112.5, endDeg: 157.5, meta: { trigram: \"☴\", dir: \"东南\" } },\n { label: \"离\", startDeg: 157.5, endDeg: 202.5, meta: { trigram: \"☲\", dir: \"南\" } },\n { label: \"坤\", startDeg: 202.5, endDeg: 247.5, meta: { trigram: \"☷\", dir: \"西南\" } },\n { label: \"兑\", startDeg: 247.5, endDeg: 292.5, meta: { trigram: \"☱\", dir: \"西\" } },\n { label: \"乾\", startDeg: 292.5, endDeg: 337.5, meta: { trigram: \"☰\", dir: \"西北\" } },\n];\n\n// =========================================\n// File: packages/luopan-react/src/theme/metalAncient.ts\n// “金属 + 磁环 + 古风” 主题（首版）\n// =========================================\nimport type { Theme } from \"@qiflow/luopan-core/types\";\n\nexport const metalAncient: Theme = {\n palette: {\n bg: \"#0d0c0a\", // 深色背景以衬托金属\n ring: \"#caa66a\", // 古铜金\n text: \"#f5e6c8\", // 米金文字\n accent: \"#e8b44c\", // 高光点缀\n },\n effects: {\n metal: true,\n glow: true,\n bevel: true,\n },\n};\n\n// =========================================\n// File: packages/luopan-react/src/utils/dpr.ts\n// =========================================\nexport const getDpr = (override?: number) => override ?? (typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1);\n\n// =========================================\n// File: packages/luopan-react/src/hooks/useDeviceOrientation.ts\n// 移动端指南针 Hook（含 iOS 权限、指数平滑、节流至 ~30Hz）\n// =========================================\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nexport interface OrientationOptions {\n enabled?: boolean;\n alphaSmoothing?: number; // 0..1, 越大越平滑\n throttleMs?: number; // 采样节流\n headingOffset?: number; // 磁偏角/手动校准\n}\n\nexport const useDeviceOrientation = (opts: OrientationOptions = {}) => {\n const { enabled = false, alphaSmoothing = 0.12, throttleMs = 33, headingOffset = 0 } = opts;\n const [heading, setHeading] = useState<number | null>(null); // 0..360\n const raf = useRef<number | null>(null);\n const lastTs = useRef<number>(0);\n const smooth = useRef<number | null>(null);\n\n const requestPermission = useCallback(async () => {\n const w = window as unknown as { DeviceOrientationEvent?: any };\n const DOE = w.DeviceOrientationEvent;\n if (DOE && typeof DOE.requestPermission === 'function') {\n try {\n const res = await DOE.requestPermission();\n return res === 'granted';\n } catch {\n return false;\n }\n }\n return true; // 非 iOS 13+\n }, []);\n\n useEffect(() => {\n if (!enabled) return;\n let mounted = true;\n\n const onOrientation = (e: DeviceOrientationEvent) => {\n const now = performance.now();\n if (now - lastTs.current < throttleMs) return;\n lastTs.current = now;\n\n // WebKit 上优先使用 webkitCompassHeading（0=北 顺时针）\n const anyE = e as any;\n let deg: number | null = null;\n if (typeof anyE.webkitCompassHeading === 'number') {\n deg = anyE.webkitCompassHeading;\n } else if (typeof e.alpha === 'number') {\n // alpha: 设备坐标系下的 z 轴旋转角，需根据实现换算\n deg = 360 - (e.alpha ?? 0);\n }\n if (deg == null) return;\n deg = ((deg + headingOffset) % 360 + 360) % 360;\n\n // 指数平滑\n if (smooth.current == null) smooth.current = deg;\n smooth.current = smooth.current * (1 - alphaSmoothing) + deg * alphaSmoothing;\n\n if (mounted) setHeading(((smooth.current % 360) + 360) % 360);\n };\n\n (async () => {\n const granted = await requestPermission();\n if (!granted) return;\n window.addEventListener('deviceorientation', onOrientation, true);\n })();\n\n return () => {\n mounted = false;\n if (raf.current) cancelAnimationFrame(raf.current);\n window.removeEventListener('deviceorientation', onOrientation, true);\n };\n }, [enabled, alphaSmoothing, throttleMs, headingOffset, requestPermission]);\n\n return { heading };\n};\n\n// =========================================\n// File: packages/luopan-react/src/renderers/canvasRenderer.ts\n// 极简 Canvas 渲染器：画环与文字（后续可替换为更复杂的金属质感）\n// =========================================\nimport type { Layer, Point, Theme } from \"@qiflow/luopan-core/types\";\n\nexport interface CanvasContext {\n ctx: CanvasRenderingContext2D;\n center: Point;\n radius: number; // logical radius\n dpr: number;\n theme: Theme;\n rotationDeg: number;\n}\n\nexport const drawLayers = (c: CanvasContext, layers: Layer[]) => {\n const { ctx, center, radius, dpr, theme } = c;\n let r = radius;\n layers.forEach((layer) => {\n const w = layer.ringWidth;\n const inner = r - w;\n\n // ring background\n ctx.beginPath();\n ctx.arc(center.x, center.y, r * dpr, 0, Math.PI * 2);\n ctx.arc(center.x, center.y, inner * dpr, 0, Math.PI * 2, true);\n ctx.closePath();\n ctx.fillStyle = layer.style?.ringFill ?? theme.palette.ring;\n ctx.fill();\n\n // text labels\n ctx.save();\n ctx.fillStyle = layer.style?.textFill ?? theme.palette.text;\n ctx.font = layer.style?.font ?? `600 ${Math.max(10, Math.floor(w * 0.35)) * dpr}px sans-serif`;\n ctx.textAlign = 'center';\n ctx.textBaseline = 'middle';\n\n layer.cells.forEach((cell) => {\n const mid = ((cell.startDeg + (angleSpan(cell.startDeg, cell.endDeg) / 2)) % 360) * Math.PI / 180;\n const rr = inner + w * 0.55; // radial position for text\n const x = center.x * dpr + Math.cos(mid) * rr * dpr;\n const y = center.y * dpr + Math.sin(mid) * rr * dpr;\n ctx.save();\n ctx.translate(x, y);\n ctx.rotate(mid);\n ctx.fillText(cell.label, 0, 0);\n ctx.restore();\n });\n\n ctx.restore();\n r = inner - Math.max(2, w * 0.06); // next ring gap\n });\n};\n\nconst angleSpan = (start: number, end: number) => {\n const s = ((start % 360) + 360) % 360;\n const e = ((end % 360) + 360) % 360;\n return s <= e ? (e - s) : (360 - s + e);\n};\n\n// =========================================\n// File: packages/luopan-react/src/Luopan.tsx\n// 最小可运行版：渲染 24 山 + 八卦两层；支持受控 angle、DPR、自适应尺寸\n// =========================================\n'use client';\nimport React, { useEffect, useMemo, useRef } from 'react';\nimport type { Layer, Theme } from '@qiflow/luopan-core/types';\nimport { MOUNTAIN_24 } from '@qiflow/luopan-core/constants/24mountains';\nimport { BAGUA_POSTERIOR } from '@qiflow/luopan-core/constants/bagua';\nimport { metalAncient } from './theme/metalAncient';\nimport { drawLayers } from './renderers/canvasRenderer';\nimport { getDpr } from './utils/dpr';\n\nexport interface LuopanProps {\n size?: number; // logical px (不含 DPR)\n angle?: number; // 受控角度 (0..360)，0 = 指向北\n theme?: Theme;\n dpiScale?: number; // 覆盖 DPR\n}\n\nexport const Luopan: React.FC<LuopanProps> = ({ size = 320, angle = 0, theme = metalAncient, dpiScale }) => {\n const canvasRef = useRef<HTMLCanvasElement | null>(null);\n const dpr = getDpr(dpiScale);\n\n const layers = useMemo<Layer[]>(() => {\n return [\n {\n id: 'layer-24mountains',\n name: '24山',\n ringWidth: size * 0.18,\n cells: MOUNTAIN_24,\n style: { ringFill: theme.palette.ring, textFill: theme.palette.text, font: `600 ${Math.floor(size * 0.055)}px 'Noto Serif SC', 'Songti SC', serif` },\n },\n {\n id: 'layer-bagua',\n name: '后天八卦',\n ringWidth: size * 0.12,\n cells: BAGUA_POSTERIOR,\n style: { ringFill: '#3b2f1b', textFill: theme.palette.accent, font: `700 ${Math.floor(size * 0.06)}px 'Noto Serif SC', serif` },\n },\n ];\n }, [size, theme]);\n\n useEffect(() => {\n const canvas = canvasRef.current;\n if (!canvas) return;\n\n const logical = size;\n const radius = logical / 2 - Math.floor(logical * 0.04);\n\n canvas.width = Math.floor(logical * dpr);\n canvas.height = Math.floor(logical * dpr);\n canvas.style.width = `${logical}px`;\n canvas.style.height = `${logical}px`;\n\n const ctx = canvas.getContext('2d');\n if (!ctx) return;\n\n // 背景\n ctx.clearRect(0, 0, canvas.width, canvas.height);\n ctx.fillStyle = theme.palette.bg;\n ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n // 坐标系移至中心，并应用旋转\n ctx.save();\n const cx = (canvas.width) / 2;\n const cy = (canvas.height) / 2;\n ctx.translate(cx, cy);\n ctx.rotate((angle * Math.PI) / 180);\n ctx.translate(-cx, -cy);\n\n drawLayers(\n {\n ctx,\n center: { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 },\n radius,\n dpr,\n theme,\n rotationDeg: angle,\n },\n layers\n );\n\n // 中心指针 / 磁环（极简版）\n ctx.restore();\n ctx.save();\n ctx.translate(cx, cy);\n // 外圈指针套环\n const ringR = Math.max(6, radius * dpr * 0.08);\n const grd = ctx.createRadialGradient(0,0, ringR*0.2, 0,0, ringR);\n grd.addColorStop(0, '#fff3');\n grd.addColorStop(1, theme.palette.accent);\n ctx.beginPath(); ctx.arc(0,0, ringR, 0, Math.PI*2); ctx.fillStyle = grd; ctx.fill();\n // 指向北的刻线（固定在页面坐标，非随盘旋转）\n ctx.rotate(0);\n ctx.strokeStyle = theme.palette.accent;\n ctx.lineWidth = Math.max(1, dpr * 1.5);\n ctx.beginPath(); ctx.moveTo(0, -radius * dpr); ctx.lineTo(0, - (radius * dpr - 18)); ctx.stroke();\n ctx.restore();\n }, [size, dpr, angle, theme, layers]);\n\n return <canvas ref={canvasRef} aria-label=\"Luopan Compass\" />;\n};\n\nexport default Luopan;\n\n// =========================================\n// File: apps/qiflow-web/app/fengshui/compass/page.tsx\n// Next.js 页面最小示例（CSR），演示 angle 受控渲染\n// =========================================\n'use client';\nimport React, { useState } from 'react';\nimport { Luopan } from '@qiflow/luopan-react/Luopan';\nimport { useDeviceOrientation } from '@qiflow/luopan-react/hooks/useDeviceOrientation';\n\nexport default function Page() {\n const [manual, setManual] = useState(0);\n const [follow, setFollow] = useState(false);\n const { heading } = useDeviceOrientation({ enabled: follow, headingOffset: 0 });\n\n const angle = follow && heading != null ? heading : manual;\n\n return (\n <div style={{ padding: 16, color: '#f5e6c8', background: '#0d0c0a', minHeight: '100dvh' }}>\n <h1 style={{ fontFamily: 'Noto Serif SC, serif' }}>QiFlow · 风水罗盘</h1>\n <div style={{ display: 'flex', gap: 24, alignItems: 'center', flexWrap: 'wrap' }}>\n <Luopan size={320} angle={angle} />\n <div>\n <label style={{ display: 'block', marginBottom: 8 }}>角度：{angle.toFixed(1)}°</label>\n <input type=\"range\" min={0} max={360} step={0.1} value={manual} onChange={(e) => setManual(parseFloat(e.target.value))} disabled={follow} />\n <div style={{ marginTop: 12 }}>\n <label>\n <input type=\"checkbox\" checked={follow} onChange={(e) => setFollow(e.target.checked)} />\n 跟随设备方向（iOS 需授权）\n </label>\n </div>\n </div>\n </div>\n </div>\n );\n}\n"}
```
好了！我把**最小可运行版**的组件、常量和设备方向 Hook 都放到右侧画布里了（包含多文件：`types.ts`、`24mountains.ts`、`bagua.ts`、`Luopan.tsx`、`useDeviceOrientation.ts`、渲染器等，以及 Next.js 示例页）。你可以直接复制到你的 monorepo 里跑起来。

### 接下来怎么做（一步到位指引）
1) **安装字体与依赖**
- 前端引入一款宋体/楷体（如 Noto Serif SC）增强古风质感。
- 确保你的 TS 路径别名指到 `@qiflow/luopan-core` 和 `@qiflow/luopan-react`，或直接用相对路径。

2) **在 Next.js 里试运行**
- 新建页面 `app/fengshui/compass/page.tsx`（画布已给示例）。
- 先手动拖动角度确认渲染正常，再勾选“跟随设备方向”在手机上测试 iOS 权限弹窗与指针平滑。

3) **与你的 QiFlow 数据打通**
- 后续把你的飞星/八字计算接成一个 `layers` 生成器（把结果映射成 `Layer[]`）。
- 想要九宫飞星叠加：在 `layers` 里增加一层九宫/飞星环或中心九宫格组件。

4) **“金属 + 磁环 + 古风”皮肤加深**
- 现在是首版：已经有配色与少量高光。下一步在 `canvasRenderer` 里增加径向渐变、内阴影、拉丝纹理；在中心加“磁环”动画（周期性旋转的高光弧）。
- 如果想更逼真：把金属外圈单独抽成 `drawMetalBezel()`，用多重渐变 + 高光切面。

5) **移动端细化**
- 手势旋转 Hook（单指旋转 + 阻尼）→ 可加入到 `Luopan.tsx`。
- DPR/Retina 已支持；老机型上可用 `requestAnimationFrame` 合帧，降级阴影。

6) **下一批我可以补充**
- `flyingStars.ts`（九运 2024–2043 的玄空飞星计算 + Vitest 单测）
- `flyingStarLayer.ts`（把结果映射到环或中心九宫）
- `metalAncient` 主题的高级金属/浮雕/发光绘制函数
- Storybook + 视觉回归（Playwright）脚手架

需要我把**飞星算法模块 + 单测**也直接落出来吗？你点头，我就把那两份文件加到画布里并接好到组件参数上。

---
## 🧑‍💻 User

好的

---
## 🤖 Assistant

> **Updating code and tests**
> I need to continue building the code for `flyingStars.ts`, `flyingStarLayer.ts`, tests, and make updates to `Luopan.tsx` to handle the layers prop. I'll proceed by updating the canvas, adding new files in line with previous steps. Once added, I'll mention how to run it briefly, with no web queries needed.>

> **Adding new files and updating code**
> I’m going to append new files to the document, which includes `flyingStars.ts` with the basic algorithm and calculations for period and grid mapping. Instead of overcomplicating things, I’ll provide a simplified model that computes the base star for the center. After that, I will provide usage instructions without code citations.>

> **Adding tests and updates**
> I’m planning to add
> *Thought for 37s*


```json
{"updates":[{"pattern":"\\Z","multiple":false,"replacement":"\n\n// =========================================\n// File: packages/luopan-core/src/flyingStars.ts\n// 玄空飞星（简化可用版）：九运（默认 9 运 2024–2043），支持山星/向星/年/月星\n// 说明：本实现遵循常见的后天洛书九宫飞布与入中替卦思路，用于产品原型与可视化；\n// 如需更严谨版本，可替换 computeBaseChart / computePeriod 等函数中的推算表。\n// =========================================\nimport type { Degree } from './types';\n\nexport type NineCells<T = number> = [T, T, T, T, T, T, T, T, T];\n// 索引布局（0..8）：\n// [0 1 2]\n// [3 4 5]\n// [6 7 8]\n\nexport interface FlyingStarParams {\n /** 第几运（1..9），默认根据年份推断；2024–2043 视为 9 运 */\n period?: 1|2|3|4|5|6|7|8|9;\n /** 阳历年（用于自动推断运/年/月星） */\n year?: number;\n /** 面向度数（0..360，房屋向） */\n facingDeg: Degree;\n /** 坐向度数（可选）；若未传，将以 facingDeg + 180 计算 */\n sittingDeg?: Degree;\n /** ISO 日期字符串（用于推算年/月星；简化版） */\n dateISO?: string;\n}\n\nexport interface FlyingStarChartCell {\n mountain: number; // 山星\n facing: number; // 向星\n annual?: number; // 年星（可选）\n monthly?: number; // 月星（可选）\n}\n\nexport interface FlyingStarChart {\n period: 1|2|3|4|5|6|7|8|9;\n grid: NineCells<FlyingStarChartCell>;\n}\n\nconst clamp = (n: number) => ((n % 9) + 9) % 9; // 0..8 循环\nconst degNorm = (d: number) => ((d % 360) + 360) % 360;\n\n/**\n * 简化：按年份推断九运（注意真实玄空以入囚/交接等细节划分，本函数用于产品原型）\n */\nexport function inferPeriodByYear(year?: number): 1|2|3|4|5|6|7|8|9 {\n if (!year) return 9;\n if (year >= 2024 && year <= 2043) return 9;\n if (year >= 2004 && year <= 2023) return 8;\n if (year >= 1984 && year <= 2003) return 7;\n // 粗略回推：每运 20 年\n const base = 1864; // 一运起点（常用）\n const diff = Math.floor((year - base) / 20);\n return ((diff % 9) + 9) % 9 + 1 as 1|2|3|4|5|6|7|8|9;\n}\n\n/**\n * 依据坐向与向星顺逆飞规则构造基础盘（山星/向星）\n * 这里给出常见的“替卦入中再飞布”的简化实现：\n * - 中宫入 period 星\n * - 依据 facing 所属卦象（方位象限）决定顺飞或逆飞（简化：面南/东南/东/东北 → 顺飞；面北/西北/西/西南 → 逆飞）\n */\nexport function computeBaseChart(period: 1|2|3|4|5|6|7|8|9, facingDeg: Degree): NineCells<number> {\n const center = period; // 中宫起 period\n const seqForward: NineCells<number> = [\n 8,1,6,\n 3,5,7,\n 4,9,2,\n ]; // 洛书顺飞模板（示意）\n const seqBackward: NineCells<number> = [\n 2,9,4,\n 7,5,3,\n 6,1,8,\n ]; // 逆序模板（示意）\n\n const d = degNorm(facingDeg);\n const forward = (d >= 45 && d < 225); // 面东(含南东)/南 → 顺；其余 → 逆（简化分区）\n\n // 把中宫换成 period，并据顺/逆把数序偏移到以中宫为 period 的盘\n const base = forward ? seqForward : seqBackward;\n const idxOf5 = base.findIndex(n => n === 5);\n const shift = ((period - 5) + 9) % 9; // 5 调到 period 的位移\n const remap = base.map(n => ((n + shift -1) % 9) + 1) as NineCells<number>;\n // remap 的中宫应为 period\n if (remap[^4] !== period) {\n // 简单纠正：强制中宫为 period（原型容错）\n remap[^4] = period;\n }\n return remap;\n}\n\n/**\n * 简化：把向星/山星分配到九宫\n * 规则（产品原型版）：\n * - 面向所在的宫 → 向星加权；对宫 → 山星加权；\n * - 这里先用基础盘相同分布，后续可按挨星法细化。\n */\nexport function buildMountainFacing(base: NineCells<number>, facingDeg: Degree, sittingDeg?: Degree): NineCells<FlyingStarChartCell> {\n const sit = sittingDeg ?? degNorm(facingDeg + 180);\n const facingIdx = degToLoShuIndex(facingDeg);\n const sittingIdx = degToLoShuIndex(sit);\n\n const grid = base.map((n, i) => ({ mountain: n, facing: n })) as NineCells<FlyingStarChartCell>;\n // 简单加权：将面向宫的 facing +1、坐宫的 mountain +1（>9 回到 1）\n grid[facingIdx].facing = ((grid[facingIdx].facing) % 9) + 1;\n grid[sittingIdx].mountain = ((grid[sittingIdx].mountain) % 9) + 1;\n return grid;\n}\n\n/** 将度数映射到九宫索引（简化以 8 方 + 中心权重） */\nexport function degToLoShuIndex(deg: Degree): number {\n const d = degNorm(deg);\n // 以正北=0° 对应上中（索引 1），顺时针每 45° 一格。这里做一个近似映射：\n // 北:1, 东北:2, 东:5, 东南:8, 南:7, 西南:6, 西:3, 西北:0；中心:4 不直接用角度。\n const sectors: {range:[number,number], idx:number}[] = [\n { range:[337.5, 360], idx:1 },{ range:[0,22.5], idx:1 },\n { range:[22.5,67.5], idx:2 },\n { range:[67.5,112.5], idx:5 },\n { range:[112.5,157.5], idx:8 },\n { range:[157.5,202.5], idx:7 },\n { range:[202.5,247.5], idx:6 },\n { range:[247.5,292.5], idx:3 },\n { range:[292.5,337.5], idx:0 },\n ];\n const hit = sectors.find(s => (d >= s.range[^0] && d < s.range[^1]) || (s.range[^0] > s.range[^1] && (d>=s.range[^0] || d<s.range[^1])));\n return hit ? hit.idx : 4; // 默认中心\n}\n\n/**\n * 年/月星（极简示意）：按九星循环推移。\n */\nexport function computeAnnualStar(year?: number): number | undefined {\n if (!year) return undefined;\n const base = 2024; // 9 运首年 → 以 9 为年星起点示意\n const n = ((year - base) % 9 + 9) % 9;\n return ((9 - n - 1) % 9) + 1; // 逆推一圈示意\n}\n\nexport function computeMonthlyStar(year?: number, month?: number): number | undefined {\n if (!year || !month) return undefined;\n const offset = ((year * 12 + month) - (2024 * 12 + 1));\n const n = ((offset % 9) + 9) % 9;\n return ((9 - n - 1) % 9) + 1;\n}\n\nexport function computeFlyingStars(params: FlyingStarParams): FlyingStarChart {\n const period = params.period ?? inferPeriodByYear(params.year);\n const base = computeBaseChart(period, params.facingDeg);\n const grid = buildMountainFacing(base, params.facingDeg, params.sittingDeg);\n\n // 年/月星（中心附注，或展示到所有宫的辅助字段）\n const date = params.dateISO ? new Date(params.dateISO) : undefined;\n const y = date?.getUTCFullYear() ?? params.year;\n const m = date ? (date.getUTCMonth() + 1) : undefined;\n const annual = computeAnnualStar(y);\n const monthly = computeMonthlyStar(y, m);\n\n const enriched = grid.map(cell => ({ ...cell, annual, monthly })) as NineCells<FlyingStarChartCell>;\n return { period, grid: enriched };\n}\n\n// =========================================\n// File: packages/luopan-core/tests/flyingStars.spec.ts\n// Vitest 单测样例（3 组）\n// =========================================\nimport { describe, it, expect } from 'vitest';\nimport { computeFlyingStars, inferPeriodByYear, degToLoShuIndex } from '../src/flyingStars';\n\ndescribe('inferPeriodByYear', () => {\n it('recognizes 9th period for 2025', () => {\n expect(inferPeriodByYear(2025)).toBe(9);\n });\n it('recognizes 8th period for 2010', () => {\n expect(inferPeriodByYear(2010)).toBe(8);\n });\n});\n\ndescribe('degToLoShuIndex', () => {\n it('maps north ~0° to index 1', () => {\n expect(degToLoShuIndex(0)).toBe(1);\n });\n it('maps east ~90° to index 5', () => {\n expect(degToLoShuIndex(90)).toBe(5);\n });\n});\n\ndescribe('computeFlyingStars', () => {\n it('produces 9-grid with mountain/facing fields', () => {\n const chart = computeFlyingStars({ facingDeg: 180, year: 2025 });\n expect(chart.period).toBe(9);\n expect(chart.grid).toHaveLength(9);\n expect(chart.grid[^4].mountain).toBeTypeOf('number');\n expect(chart.grid[^4].facing).toBeTypeOf('number');\n });\n});\n\n// =========================================\n// File: packages/luopan-react/src/layers/flyingStarLayer.ts\n// 将九宫飞星结果以中心九宫覆盖到罗盘上（覆盖绘制，不占用外环宽度）\n// =========================================\nimport type { Theme } from '@qiflow/luopan-core/types';\nimport type { FlyingStarChart } from '@qiflow/luopan-core/flyingStars';\n\nexport interface FlyingStarOverlayOptions {\n size: number; // 逻辑像素（Luopan 尺寸）\n dpr: number;\n theme: Theme;\n}\n\nexport function drawFlyingStarOverlay(\n ctx: CanvasRenderingContext2D,\n chart: FlyingStarChart,\n opts: FlyingStarOverlayOptions\n) {\n const { size, dpr, theme } = opts;\n const cell = Math.floor((size * 0.6) / 3); // 中心九宫占用 60% 宽度\n const start = Math.floor((size - cell * 3) / 2);\n\n ctx.save();\n ctx.scale(dpr, dpr);\n ctx.translate(0, 0);\n ctx.strokeStyle = theme.palette.ring;\n ctx.lineWidth = Math.max(1, 1.2 * dpr);\n ctx.fillStyle = theme.palette.text;\n ctx.font = `700 ${Math.floor(cell * 0.28)}px 'Noto Serif SC', serif`;\n ctx.textAlign = 'center';\n ctx.textBaseline = 'middle';\n\n // 画 3x3 九宫格\n for (let r = 0; r < 3; r++) {\n for (let c = 0; c < 3; c++) {\n const x = start + c * cell;\n const y = start + r * cell;\n ctx.strokeRect(x, y, cell, cell);\n const idx = r * 3 + c; // 与 NineCells 索引一致\n const g = chart.grid[idx];\n const line1 = `${g.mountain}/${g.facing}`;\n const line2 = `${g.annual ?? ''}${g.monthly ? '/' + g.monthly : ''}`;\n ctx.fillText(line1, x + cell / 2, y + cell * 0.42);\n if (line2) ctx.fillText(line2, x + cell / 2, y + cell * 0.72);\n }\n }\n\n // 标注中心 period\n ctx.fillStyle = theme.palette.accent;\n ctx.font = `800 ${Math.floor(cell * 0.32)}px 'Noto Serif SC', serif`;\n ctx.fillText(`运${chart.period}`, size / 2, start + cell * 1.5);\n\n ctx.restore();\n}\n\n// =========================================\n// USAGE NOTE (append):\n// 在 Luopan.tsx 的绘制末尾，调用 drawFlyingStarOverlay(ctx, chart, { size, dpr, theme })\n// 示例：\n// import { computeFlyingStars } from '@qiflow/luopan-core/flyingStars';\n// import { drawFlyingStarOverlay } from './layers/flyingStarLayer';\n// const chart = computeFlyingStars({ facingDeg: angle, year: 2025 });\n// drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });\n"}]}
```

```json
{"name":"QiFlow Luopan – FlyingStars模块与九宫覆盖","type":"code/react","content":"// =========================================\n// File: packages/luopan-core/src/flyingStars.ts\n// 玄空飞星（简化可用版）：九运（默认 9 运 2024–2043），支持山星/向星/年/月星\n// 说明：本实现遵循常见的后天洛书九宫飞布与入中替卦思路，用于产品原型与可视化；\n// 如需更严谨版本，可替换 computeBaseChart / computePeriod 等函数中的推算表。\n// =========================================\nimport type { Degree } from './types';\n\nexport type NineCells<T = number> = [T, T, T, T, T, T, T, T, T];\n// 索引布局（0..8）：\n// [0 1 2]\n// [3 4 5]\n// [6 7 8]\n\nexport interface FlyingStarParams {\n /** 第几运（1..9），默认根据年份推断；2024–2043 视为 9 运 */\n period?: 1|2|3|4|5|6|7|8|9;\n /** 阳历年（用于自动推断运/年/月星） */\n year?: number;\n /** 面向度数（0..360，房屋向） */\n facingDeg: Degree;\n /** 坐向度数（可选）；若未传，将以 facingDeg + 180 计算 */\n sittingDeg?: Degree;\n /** ISO 日期字符串（用于推算年/月星；简化版） */\n dateISO?: string;\n}\n\nexport interface FlyingStarChartCell {\n mountain: number; // 山星\n facing: number; // 向星\n annual?: number; // 年星（可选）\n monthly?: number; // 月星（可选）\n}\n\nexport interface FlyingStarChart {\n period: 1|2|3|4|5|6|7|8|9;\n grid: NineCells<FlyingStarChartCell>;\n}\n\nconst clamp0to8 = (n: number) => ((n % 9) + 9) % 9; // 0..8 循环\nconst degNorm = (d: number) => ((d % 360) + 360) % 360;\n\n/**\n * 简化：按年份推断九运（注意真实玄空以入囚/交接等细节划分，本函数用于产品原型）\n */\nexport function inferPeriodByYear(year?: number): 1|2|3|4|5|6|7|8|9 {\n if (!year) return 9;\n if (year >= 2024 && year <= 2043) return 9;\n if (year >= 2004 && year <= 2023) return 8;\n if (year >= 1984 && year <= 2003) return 7;\n // 粗略回推：每运 20 年\n const base = 1864; // 一运起点（常用）\n const diff = Math.floor((year - base) / 20);\n return ((diff % 9) + 9) % 9 + 1 as 1|2|3|4|5|6|7|8|9;\n}\n\n/**\n * 依据坐向与向星顺逆飞规则构造基础盘（山星/向星）\n * 这里给出常见的“替卦入中再飞布”的简化实现：\n * - 中宫入 period 星\n * - 依据 facing 所属卦象（方位象限）决定顺飞或逆飞（简化：面南/东南/东/东北 → 顺飞；面北/西北/西/西南 → 逆飞）\n */\nexport function computeBaseChart(period: 1|2|3|4|5|6|7|8|9, facingDeg: Degree): NineCells<number> {\n const seqForward: NineCells<number> = [\n 8,1,6,\n 3,5,7,\n 4,9,2,\n ]; // 洛书顺飞模板（示意）\n const seqBackward: NineCells<number> = [\n 2,9,4,\n 7,5,3,\n 6,1,8,\n ]; // 逆序模板（示意）\n\n const d = degNorm(facingDeg);\n const forward = (d >= 45 && d < 225); // 面东(含南东)/南 → 顺；其余 → 逆（简化分区）\n const base = forward ? seqForward : seqBackward;\n\n // 将中宫 5 替换为 period，并整体平移到以 period 为中宫\n const shift = ((period - 5) + 9) % 9; // 5 调到 period 的位移\n const remap = base.map(n => ((n + shift -1) % 9) + 1) as NineCells<number>;\n remap[^4] = period; // 容错：确保中宫为 period\n return remap;\n}\n\n/**\n * 简化：把向星/山星分配到九宫\n * 规则（产品原型版）：\n * - 面向所在的宫 → 向星加权；对宫 → 山星加权；\n * - 这里先用基础盘相同分布，后续可按挨星法细化。\n */\nexport function buildMountainFacing(base: NineCells<number>, facingDeg: Degree, sittingDeg?: Degree): NineCells<FlyingStarChartCell> {\n const sit = sittingDeg ?? degNorm(facingDeg + 180);\n const facingIdx = degToLoShuIndex(facingDeg);\n const sittingIdx = degToLoShuIndex(sit);\n\n const grid = base.map((n) => ({ mountain: n, facing: n })) as NineCells<FlyingStarChartCell>;\n // 简单加权：将面向宫的 facing +1、坐宫的 mountain +1（>9 回到 1）\n grid[facingIdx].facing = ((grid[facingIdx].facing) % 9) + 1;\n grid[sittingIdx].mountain = ((grid[sittingIdx].mountain) % 9) + 1;\n return grid;\n}\n\n/** 将度数映射到九宫索引（简化以 8 方 + 中心权重） */\nexport function degToLoShuIndex(deg: Degree): number {\n const d = degNorm(deg);\n // 北:1, 东北:2, 东:5, 东南:8, 南:7, 西南:6, 西:3, 西北:0；中心:4\n const sectors: {range:[number,number], idx:number}[] = [\n { range:[337.5, 360], idx:1 },{ range:[0,22.5], idx:1 },\n { range:[22.5,67.5], idx:2 },\n { range:[67.5,112.5], idx:5 },\n { range:[112.5,157.5], idx:8 },\n { range:[157.5,202.5], idx:7 },\n { range:[202.5,247.5], idx:6 },\n { range:[247.5,292.5], idx:3 },\n { range:[292.5,337.5], idx:0 },\n ];\n const hit = sectors.find(s => (d >= s.range[^0] && d < s.range[^1]) || (s.range[^0] > s.range[^1] && (d>=s.range[^0] || d<s.range[^1])));\n return hit ? hit.idx : 4; // 默认中心\n}\n\n/**\n * 年/月星（极简示意）：按九星循环推移。\n */\nexport function computeAnnualStar(year?: number): number | undefined {\n if (!year) return undefined;\n const base = 2024; // 9 运首年 → 以 9 为年星起点示意\n const n = ((year - base) % 9 + 9) % 9;\n return ((9 - n - 1) % 9) + 1; // 逆推一圈示意\n}\n\nexport function computeMonthlyStar(year?: number, month?: number): number | undefined {\n if (!year || !month) return undefined;\n const offset = ((year * 12 + month) - (2024 * 12 + 1));\n const n = ((offset % 9) + 9) % 9;\n return ((9 - n - 1) % 9) + 1;\n}\n\nexport function computeFlyingStars(params: FlyingStarParams): FlyingStarChart {\n const period = params.period ?? inferPeriodByYear(params.year);\n const base = computeBaseChart(period, params.facingDeg);\n const grid = buildMountainFacing(base, params.facingDeg, params.sittingDeg);\n\n // 年/月星（中心附注，或展示到所有宫的辅助字段）\n const date = params.dateISO ? new Date(params.dateISO) : undefined;\n const y = date?.getUTCFullYear() ?? params.year;\n const m = date ? (date.getUTCMonth() + 1) : undefined;\n const annual = computeAnnualStar(y);\n const monthly = computeMonthlyStar(y, m);\n\n const enriched = grid.map(cell => ({ ...cell, annual, monthly })) as NineCells<FlyingStarChartCell>;\n return { period, grid: enriched };\n}\n\n// =========================================\n// File: packages/luopan-core/tests/flyingStars.spec.ts\n// Vitest 单测样例（3 组）\n// =========================================\nimport { describe, it, expect } from 'vitest';\nimport { computeFlyingStars, inferPeriodByYear, degToLoShuIndex } from '../src/flyingStars';\n\ndescribe('inferPeriodByYear', () => {\n it('recognizes 9th period for 2025', () => {\n expect(inferPeriodByYear(2025)).toBe(9);\n });\n it('recognizes 8th period for 2010', () => {\n expect(inferPeriodByYear(2010)).toBe(8);\n });\n});\n\ndescribe('degToLoShuIndex', () => {\n it('maps north ~0° to index 1', () => {\n expect(degToLoShuIndex(0)).toBe(1);\n });\n it('maps east ~90° to index 5', () => {\n expect(degToLoShuIndex(90)).toBe(5);\n });\n});\n\ndescribe('computeFlyingStars', () => {\n it('produces 9-grid with mountain/facing fields', () => {\n const chart = computeFlyingStars({ facingDeg: 180, year: 2025 });\n expect(chart.period).toBe(9);\n expect(chart.grid).toHaveLength(9);\n expect(chart.grid[^4].mountain).toBeTypeOf('number');\n expect(chart.grid[^4].facing).toBeTypeOf('number');\n });\n});\n\n// =========================================\n// File: packages/luopan-react/src/layers/flyingStarLayer.ts\n// 将九宫飞星结果以中心九宫覆盖到罗盘上（覆盖绘制，不占用外环宽度）\n// =========================================\nimport type { Theme } from '@qiflow/luopan-core/types';\nimport type { FlyingStarChart } from '@qiflow/luopan-core/flyingStars';\n\nexport interface FlyingStarOverlayOptions {\n size: number; // 逻辑像素（Luopan 尺寸）\n dpr: number;\n theme: Theme;\n}\n\nexport function drawFlyingStarOverlay(\n ctx: CanvasRenderingContext2D,\n chart: FlyingStarChart,\n opts: FlyingStarOverlayOptions\n) {\n const { size, dpr, theme } = opts;\n const cell = Math.floor((size * 0.6) / 3); // 中心九宫占用 60% 宽度\n const start = Math.floor((size - cell * 3) / 2);\n\n ctx.save();\n ctx.scale(dpr, dpr);\n ctx.translate(0, 0);\n ctx.strokeStyle = theme.palette.ring;\n ctx.lineWidth = Math.max(1, 1.2 * dpr);\n ctx.fillStyle = theme.palette.text;\n ctx.font = `700 ${Math.floor(cell * 0.28)}px 'Noto Serif SC', serif`;\n ctx.textAlign = 'center';\n ctx.textBaseline = 'middle';\n\n // 画 3x3 九宫格\n for (let r = 0; r < 3; r++) {\n for (let c = 0; c < 3; c++) {\n const x = start + c * cell;\n const y = start + r * cell;\n ctx.strokeRect(x, y, cell, cell);\n const idx = r * 3 + c; // 与 NineCells 索引一致\n const g = chart.grid[idx];\n const line1 = `${g.mountain}/${g.facing}`;\n const line2 = `${g.annual ?? ''}${g.monthly ? '/' + g.monthly : ''}`;\n ctx.fillText(line1, x + cell / 2, y + cell * 0.42);\n if (line2) ctx.fillText(line2, x + cell / 2, y + cell * 0.72);\n }\n }\n\n // 标注中心 period\n ctx.fillStyle = theme.palette.accent;\n ctx.font = `800 ${Math.floor(cell * 0.32)}px 'Noto Serif SC', serif`;\n ctx.fillText(`运${chart.period}`, size / 2, start + cell * 1.5);\n\n ctx.restore();\n}\n\n// =========================================\n// USAGE NOTE（集成说明，仅注释）：\n// 在 Luopan.tsx 的绘制末尾，调用 drawFlyingStarOverlay(ctx, chart, { size, dpr, theme })\n// 示例：\n// import { computeFlyingStars } from '@qiflow/luopan-core/flyingStars';\n// import { drawFlyingStarOverlay } from './layers/flyingStarLayer';\n// const chart = computeFlyingStars({ facingDeg: angle, year: 2025 });\n// drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });\n"}
```
好了！我把**飞星算法模块 + 九宫覆盖渲染**已经放到右侧画布里了（3 个文件）：

- `packages/luopan-core/src/flyingStars.ts`（九运推断、基础盘、山/向星、年/月星；提供 `computeFlyingStars` 等）
- `packages/luopan-core/tests/flyingStars.spec.ts`（Vitest 3 组样例）
- `packages/luopan-react/src/layers/flyingStarLayer.ts`（将九宫飞星以**中心九宫**覆盖到罗盘上）

### 如何集成到你现有的 `Luopan.tsx`
在 `useEffect` 里、`drawLayers(...)` 之后，追加两行（画布注释里也写了）：
```ts
import { computeFlyingStars } from '@qiflow/luopan-core/flyingStars';
import { drawFlyingStarOverlay } from '@qiflow/luopan-react/layers/flyingStarLayer';

const chart = computeFlyingStars({ facingDeg: angle, year: 2025 }); // 或使用用户输入/定位时间
drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });
```

> 提示：`facingDeg` 用当前罗盘“向”的角度（你的组件里就是 `angle`），也可以把坐向分开传：`{ facingDeg, sittingDeg }`。`year/dateISO` 可来自用户选择或系统时间。

### 跑单测（Vitest）
在项目根：
```bash
pnpm add -D vitest
pnpm vitest run packages/luopan-core/tests/flyingStars.spec.ts
```

### 下一步建议（任选）
1) **把飞星放到“环层”而非九宫格**：如果你更想让飞星围绕外圈显示，我可以再给你一个 `flyingStarRingLayer.ts`，把 9 颗星按宫位映射为文字/符号环，和 24 山并列显示。
2) **更专业的挨星规则与节气切换**：当前实现用于原型与可视化验证；若你要精确到节令（月星/日星的交接点、交接时刻），我可以补充更严谨的表和推算接口。
3) **主题加深（金属+磁环）**：把中心“磁环”做成动态高光弧、外圈加拉丝金属与浮雕刻线（抽成 `drawMetalBezel()`、`drawGlowArc()`），并在低端机降级。

需要我把**飞星环版本**或**更严谨的推算表**也补上吗？你说一声，我直接继续往画布里加。

---
## 🧑‍💻 User

好 ，把飞星环版本或更严谨的推算表也补上，把中心“磁环”做成动态高光弧、外圈加拉丝金属与浮雕刻线（抽成 drawMetalBezel()、drawGlowArc()），并在低端机降级。

---
## 🤖 Assistant

> *Thought for 14s*


```json
{"updates":[{"pattern":"\\Z","replacement":"\n\n// =========================================\n// File: packages/luopan-core/src/constants/flyingStarTables.ts\n// 更严谨的飞星推算表（原型级）：九运起止年、洛书宫序、顺逆飞映射等\n// 备注：真实流派在交接年/节气点上存在差异，本表按通用20年一运、\n// 以公历年粗分（可在生产中按节令/立春切分）。\n// =========================================\nexport interface PeriodSpan { period: 1|2|3|4|5|6|7|8|9; startYear: number; endYear: number }\nexport const PERIOD_SPANS: PeriodSpan[] = [\n { period:1, startYear:1864, endYear:1883 },\n { period:2, startYear:1884, endYear:1903 },\n { period:3, startYear:1904, endYear:1923 },\n { period:4, startYear:1924, endYear:1943 },\n { period:5, startYear:1944, endYear:1963 },\n { period:6, startYear:1964, endYear:1983 },\n { period:7, startYear:1984, endYear:2003 },\n { period:8, startYear:2004, endYear:2023 },\n { period:9, startYear:2024, endYear:2043 },\n];\n\n// 洛书宫索引（与 NineCells 索引 0..8 对应），供可视化/映射参考\n// [0 1 2]\n// [3 4 5]\n// [6 7 8]\nexport const LO_SHU_INDEX_TO_DIRECTION = [\n '西北','北','东北',\n '西','中','东',\n '西南','南','东南',\n];\n\n// 顺飞/逆飞的基础模板（中宫为5）\nexport const LO_SHU_SEQ_FORWARD = [\n 8,1,6,\n 3,5,7,\n 4,9,2,\n] as const;\n\nexport const LO_SHU_SEQ_BACKWARD = [\n 2,9,4,\n 7,5,3,\n 6,1,8,\n] as const;\n\n// 面向度数 → 顺飞(true)/逆飞(false) 的象限近似规则（可按流派替换）\nexport function isForwardByFacingDeg(deg: number): boolean {\n const d = ((deg % 360) + 360) % 360;\n // 面东(含东南)/南 → 顺；面西(含西北)/北 → 逆\n return d >= 45 && d < 225;\n}\n\n// =========================================\n// File: packages/luopan-react/src/layers/flyingStarRingLayer.ts\n// 将飞星盘映射为“外环”Layer，可与24山并列显示\n// =========================================\nimport type { Layer, Cell } from '@qiflow/luopan-core/types';\nimport type { FlyingStarChart } from '@qiflow/luopan-core/flyingStars';\n\n// 九宫到方位近似角度（与 degToLoShuIndex 对偶）：\nconst LO_SHU_INDEX_TO_DEG: number[] = [\n 315, 0, 45,\n 270, 999, 90, // 999 中宫不渲染\n 225, 180, 135,\n];\n\nexport interface FlyingStarRingOptions {\n ringWidth: number; // px（逻辑尺寸）\n startAngle?: number; // 默认 0\n clockwise?: boolean; // 默认 true\n showAnnual?: boolean;\n showMonthly?: boolean;\n}\n\nexport function buildFlyingStarRingLayer(chart: FlyingStarChart, opts: FlyingStarRingOptions): Layer {\n const cells: Cell[] = [];\n for (let i = 0; i < 9; i++) {\n const center = LO_SHU_INDEX_TO_DEG[i];\n if (center === 999) continue; // 中宫不作环\n const span = 40; // 每宫环占角度（可参数化）\n const startDeg = ((center - span/2) + 360) % 360;\n const endDeg = ((center + span/2) + 360) % 360;\n const g = chart.grid[i];\n const label = `${g.mountain}/${g.facing}` +\n ((opts.showAnnual && g.annual) ? `·年${g.annual}` : '') +\n ((opts.showMonthly && g.monthly) ? `·月${g.monthly}` : '');\n cells.push({ label, startDeg, endDeg, meta: { idx: i } });\n }\n\n const layer: Layer = {\n id: 'layer-flying-star-ring',\n name: '飞星环',\n ringWidth: opts.ringWidth,\n startAngle: opts.startAngle ?? 0,\n clockwise: opts.clockwise ?? true,\n cells,\n style: {\n ringFill: '#2a2216',\n textFill: '#f0d9a1',\n font: `700 ${Math.max(10, Math.floor(opts.ringWidth * 0.28))}px 'Noto Serif SC', serif`,\n },\n };\n return layer;\n}\n\n// =========================================\n// File: packages/luopan-react/src/visual/metalEffects.ts\n// 金属外圈（拉丝/浮雕）与中心“磁环”动态高光弧；含低端机降级策略\n// =========================================\nimport type { Theme, Point } from '@qiflow/luopan-core/types';\n\nexport function isLowEndDevice(): boolean {\n if (typeof navigator === 'undefined') return false;\n // 粗略启发式：逻辑核数 ≤ 4 或 内存 ≤ 4GB（部分环境不暴露）→ 视为低端\n const cores = (navigator as any).hardwareConcurrency ?? 4;\n const mem = (navigator as any).deviceMemory ?? 4;\n return cores <= 4 || mem <= 4;\n}\n\nexport function drawMetalBezel(\n ctx: CanvasRenderingContext2D,\n center: Point,\n outerR: number, // 画布像素（已含 DPR）\n innerR: number,\n theme: Theme,\n opts?: { brushed?: boolean; bevel?: boolean }\n) {\n const g = ctx.createRadialGradient(center.x, center.y, innerR, center.x, center.y, outerR);\n g.addColorStop(0.0, '#3a2c18');\n g.addColorStop(0.45, theme.palette.ring);\n g.addColorStop(0.85, '#6e532f');\n g.addColorStop(1.0, '#1a130b');\n ctx.save();\n ctx.beginPath();\n ctx.arc(center.x, center.y, outerR, 0, Math.PI * 2);\n ctx.arc(center.x, center.y, innerR, 0, Math.PI * 2, true);\n ctx.closePath();\n ctx.fillStyle = g;\n ctx.fill();\n\n if (opts?.brushed) {\n // 拉丝：沿切线方向的细线条噪声（低端机降级为跳过）\n const strokes = isLowEndDevice() ? 0 : Math.max(20, Math.floor((outerR - innerR) / 3));\n ctx.globalAlpha = 0.08;\n ctx.strokeStyle = '#fff';\n for (let i = 0; i < strokes; i++) {\n const a = (i / strokes) * Math.PI * 2;\n const x1 = center.x + Math.cos(a) * innerR;\n const y1 = center.y + Math.sin(a) * innerR;\n const x2 = center.x + Math.cos(a) * outerR;\n const y2 = center.y + Math.sin(a) * outerR;\n ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();\n }\n ctx.globalAlpha = 1;\n }\n\n if (opts?.bevel) {\n // 浮雕：内外圈高光/暗部描边\n ctx.lineWidth = Math.max(1, (outerR - innerR) * 0.06);\n ctx.strokeStyle = '#ffffff22';\n ctx.beginPath(); ctx.arc(center.x, center.y, outerR * 0.98, 0, Math.PI * 2); ctx.stroke();\n ctx.strokeStyle = '#00000066';\n ctx.beginPath(); ctx.arc(center.x, center.y, innerR * 1.02, 0, Math.PI * 2); ctx.stroke();\n }\n ctx.restore();\n}\n\nexport function drawGlowArc(\n ctx: CanvasRenderingContext2D,\n center: Point,\n radius: number, // 画布像素（已含 DPR）\n progress: number, // 0..1，动画相位\n theme: Theme\n) {\n // 高光弧随时间旋转，模拟“磁环”流动高光\n const start = progress * Math.PI * 2;\n const end = start + Math.PI * 0.5; // 90° 高光段\n const grad = ctx.createConicGradient(start, center.x, center.y);\n grad.addColorStop(0, '#ffffff66');\n grad.addColorStop(0.5, theme.palette.accent + '99');\n grad.addColorStop(1, '#ffffff00');\n\n ctx.save();\n ctx.globalCompositeOperation = 'lighter';\n ctx.lineWidth = Math.max(2, radius * 0.06);\n ctx.strokeStyle = grad as unknown as string;\n ctx.beginPath();\n ctx.arc(center.x, center.y, radius, start, end);\n ctx.stroke();\n ctx.restore();\n}\n\n// =========================================\n// File: packages/luopan-react/src/Luopan.tsx (PATCH)\n// - 支持可选飞星“外环/中心九宫”渲染\n// - 集成金属外圈/磁环高光（含低端机降级）\n// =========================================\n/* PATCH START */\n'use client';\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport type { Layer, Theme } from '@qiflow/luopan-core/types';\nimport { MOUNTAIN_24 } from '@qiflow/luopan-core/constants/24mountains';\nimport { BAGUA_POSTERIOR } from '@qiflow/luopan-core/constants/bagua';\nimport { metalAncient } from './theme/metalAncient';\nimport { drawLayers } from './renderers/canvasRenderer';\nimport { getDpr } from './utils/dpr';\nimport { computeFlyingStars } from '@qiflow/luopan-core/flyingStars';\nimport { drawFlyingStarOverlay } from './layers/flyingStarLayer';\nimport { buildFlyingStarRingLayer } from './layers/flyingStarRingLayer';\nimport { drawMetalBezel, drawGlowArc, isLowEndDevice } from './visual/metalEffects';\n\nexport interface LuopanProps {\n size?: number;\n angle?: number;\n theme?: Theme;\n dpiScale?: number;\n showFlyingStarOverlay?: boolean; // 中心九宫\n showFlyingStarRing?: boolean; // 外环\n}\n\nexport const Luopan: React.FC<LuopanProps> = ({\n size = 320,\n angle = 0,\n theme = metalAncient,\n dpiScale,\n showFlyingStarOverlay = true,\n showFlyingStarRing = false,\n}) => {\n const canvasRef = useRef<HTMLCanvasElement | null>(null);\n const dpr = getDpr(dpiScale);\n const [t, setT] = useState(0); // 动画相位 0..1\n\n const layers = useMemo<Layer[]>(() => {\n const base: Layer[] = [\n {\n id: 'layer-24mountains',\n name: '24山',\n ringWidth: size * 0.18,\n cells: MOUNTAIN_24,\n style: { ringFill: theme.palette.ring, textFill: theme.palette.text, font: `600 ${Math.floor(size * 0.055)}px 'Noto Serif SC', 'Songti SC', serif` },\n },\n {\n id: 'layer-bagua',\n name: '后天八卦',\n ringWidth: size * 0.12,\n cells: BAGUA_POSTERIOR,\n style: { ringFill: '#3b2f1b', textFill: theme.palette.accent, font: `700 ${Math.floor(size * 0.06)}px 'Noto Serif SC', serif` },\n },\n ];\n\n if (showFlyingStarRing) {\n const chart = computeFlyingStars({ facingDeg: angle, year: new Date().getFullYear() });\n base.unshift(buildFlyingStarRingLayer(chart, { ringWidth: size * 0.12, showAnnual: true, showMonthly: true }));\n }\n return base;\n }, [size, theme, angle, showFlyingStarRing]);\n\n useEffect(() => {\n const canvas = canvasRef.current;\n if (!canvas) return;\n\n const logical = size;\n const radius = logical / 2 - Math.floor(logical * 0.04);\n\n canvas.width = Math.floor(logical * dpr);\n canvas.height = Math.floor(logical * dpr);\n canvas.style.width = `${logical}px`;\n canvas.style.height = `${logical}px`;\n\n const ctx = canvas.getContext('2d');\n if (!ctx) return;\n\n // 背景\n ctx.clearRect(0, 0, canvas.width, canvas.height);\n ctx.fillStyle = theme.palette.bg;\n ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n const cx = (canvas.width) / 2;\n const cy = (canvas.height) / 2;\n\n // 金属外圈（固定在屏幕坐标，不随罗盘旋转）\n const bezelOuter = radius * dpr + Math.max(8, dpr * 6);\n const bezelInner = radius * dpr - Math.max(6, dpr * 4);\n drawMetalBezel(ctx, { x: cx, y: cy }, bezelOuter, bezelInner, theme, { brushed: !isLowEndDevice(), bevel: true });\n\n // 盘面旋转层\n ctx.save();\n ctx.translate(cx, cy);\n ctx.rotate((angle * Math.PI) / 180);\n ctx.translate(-cx, -cy);\n\n drawLayers(\n {\n ctx,\n center: { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 },\n radius,\n dpr,\n theme,\n rotationDeg: angle,\n },\n layers\n );\n ctx.restore();\n\n // 中心“磁环”高光弧（动画）\n if (!isLowEndDevice()) {\n drawGlowArc(ctx, { x: cx, y: cy }, Math.max(10, radius * dpr * 0.14), t, theme);\n }\n\n // 中心九宫覆盖\n if (showFlyingStarOverlay) {\n const chart = computeFlyingStars({ facingDeg: angle, year: new Date().getFullYear() });\n drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });\n }\n }, [size, dpr, angle, theme, layers, t, showFlyingStarOverlay]);\n\n // 动画时钟（仅高端机启用）\n useEffect(() => {\n if (isLowEndDevice()) return; // 降级：关闭动画\n let raf = 0;\n let running = true;\n const tick = () => {\n setT(prev => (prev + 0.012) % 1);\n if (running) raf = requestAnimationFrame(tick);\n };\n raf = requestAnimationFrame(tick);\n return () => { running = false; cancelAnimationFrame(raf); };\n }, []);\n\n return <canvas ref={canvasRef} aria-label=\"Luopan Compass\" />;\n};\n/* PATCH END */\n"}]}
```

```json
{"name":"QiFlow Luopan – 飞星环 + 更严谨推算表 + 金属磁环特效（React/TS）","type":"code/react","content":"// =========================================\n// File: packages/luopan-core/src/constants/flyingStarTables.ts\n// 更严谨的飞星推算表（原型级）：九运起止年、洛书宫序、顺逆飞映射等\n// 备注：真实流派在交接年/节气点上存在差异，本表按通用20年一运、\n// 以公历年粗分（可在生产中按节令/立春切分）。\n// =========================================\nexport interface PeriodSpan { period: 1|2|3|4|5|6|7|8|9; startYear: number; endYear: number }\nexport const PERIOD_SPANS: PeriodSpan[] = [\n { period:1, startYear:1864, endYear:1883 },\n { period:2, startYear:1884, endYear:1903 },\n { period:3, startYear:1904, endYear:1923 },\n { period:4, startYear:1924, endYear:1943 },\n { period:5, startYear:1944, endYear:1963 },\n { period:6, startYear:1964, endYear:1983 },\n { period:7, startYear:1984, endYear:2003 },\n { period:8, startYear:2004, endYear:2023 },\n { period:9, startYear:2024, endYear:2043 },\n];\n\n// 洛书宫索引（与 NineCells 索引 0..8 对应），供可视化/映射参考\n// [0 1 2]\n// [3 4 5]\n// [6 7 8]\nexport const LO_SHU_INDEX_TO_DIRECTION = [\n '西北','北','东北',\n '西','中','东',\n '西南','南','东南',\n];\n\n// 顺飞/逆飞的基础模板（中宫为5）\nexport const LO_SHU_SEQ_FORWARD = [\n 8,1,6,\n 3,5,7,\n 4,9,2,\n] as const;\n\nexport const LO_SHU_SEQ_BACKWARD = [\n 2,9,4,\n 7,5,3,\n 6,1,8,\n] as const;\n\n// 面向度数 → 顺飞(true)/逆飞(false) 的象限近似规则（可按流派替换）\nexport function isForwardByFacingDeg(deg: number): boolean {\n const d = ((deg % 360) + 360) % 360;\n // 面东(含东南)/南 → 顺；面西(含西北)/北 → 逆\n return d >= 45 && d < 225;\n}\n\n// =========================================\n// File: packages/luopan-react/src/layers/flyingStarRingLayer.ts\n// 将飞星盘映射为“外环”Layer，可与24山并列显示\n// =========================================\nimport type { Layer, Cell } from '@qiflow/luopan-core/types';\nimport type { FlyingStarChart } from '@qiflow/luopan-core/flyingStars';\n\n// 九宫到方位近似角度（与 degToLoShuIndex 对偶）：\nconst LO_SHU_INDEX_TO_DEG: number[] = [\n 315, 0, 45,\n 270, 999, 90, // 999 中宫不渲染\n 225, 180, 135,\n];\n\nexport interface FlyingStarRingOptions {\n ringWidth: number; // px（逻辑尺寸）\n startAngle?: number; // 默认 0\n clockwise?: boolean; // 默认 true\n showAnnual?: boolean;\n showMonthly?: boolean;\n}\n\nexport function buildFlyingStarRingLayer(chart: FlyingStarChart, opts: FlyingStarRingOptions): Layer {\n const cells: Cell[] = [];\n for (let i = 0; i < 9; i++) {\n const center = LO_SHU_INDEX_TO_DEG[i];\n if (center === 999) continue; // 中宫不作环\n const span = 40; // 每宫环占角度（可参数化）\n const startDeg = ((center - span/2) + 360) % 360;\n const endDeg = ((center + span/2) + 360) % 360;\n const g = chart.grid[i];\n const label = `${g.mountain}/${g.facing}` +\n ((opts.showAnnual && g.annual) ? `·年${g.annual}` : '') +\n ((opts.showMonthly && g.monthly) ? `·月${g.monthly}` : '');\n cells.push({ label, startDeg, endDeg, meta: { idx: i } });\n }\n\n const layer: Layer = {\n id: 'layer-flying-star-ring',\n name: '飞星环',\n ringWidth: opts.ringWidth,\n startAngle: opts.startAngle ?? 0,\n clockwise: opts.clockwise ?? true,\n cells,\n style: {\n ringFill: '#2a2216',\n textFill: '#f0d9a1',\n font: `700 ${Math.max(10, Math.floor(opts.ringWidth * 0.28))}px 'Noto Serif SC', serif`,\n },\n };\n return layer;\n}\n\n// =========================================\n// File: packages/luopan-react/src/visual/metalEffects.ts\n// 金属外圈（拉丝/浮雕）与中心“磁环”动态高光弧；含低端机降级策略\n// =========================================\nimport type { Theme, Point } from '@qiflow/luopan-core/types';\n\nexport function isLowEndDevice(): boolean {\n if (typeof navigator === 'undefined') return false;\n // 粗略启发式：逻辑核数 ≤ 4 或 内存 ≤ 4GB（部分环境不暴露）→ 视为低端\n const cores = (navigator as any).hardwareConcurrency ?? 4;\n const mem = (navigator as any).deviceMemory ?? 4;\n return cores <= 4 || mem <= 4;\n}\n\nexport function drawMetalBezel(\n ctx: CanvasRenderingContext2D,\n center: Point,\n outerR: number, // 画布像素（已含 DPR）\n innerR: number,\n theme: Theme,\n opts?: { brushed?: boolean; bevel?: boolean }\n) {\n const g = ctx.createRadialGradient(center.x, center.y, innerR, center.x, center.y, outerR);\n g.addColorStop(0.0, '#3a2c18');\n g.addColorStop(0.45, theme.palette.ring);\n g.addColorStop(0.85, '#6e532f');\n g.addColorStop(1.0, '#1a130b');\n ctx.save();\n ctx.beginPath();\n ctx.arc(center.x, center.y, outerR, 0, Math.PI * 2);\n ctx.arc(center.x, center.y, innerR, 0, Math.PI * 2, true);\n ctx.closePath();\n ctx.fillStyle = g;\n ctx.fill();\n\n if (opts?.brushed) {\n // 拉丝：沿切线方向的细线条噪声（低端机降级为跳过）\n const strokes = isLowEndDevice() ? 0 : Math.max(20, Math.floor((outerR - innerR) / 3));\n ctx.globalAlpha = 0.08;\n ctx.strokeStyle = '#fff';\n for (let i = 0; i < strokes; i++) {\n const a = (i / strokes) * Math.PI * 2;\n const x1 = center.x + Math.cos(a) * innerR;\n const y1 = center.y + Math.sin(a) * innerR;\n const x2 = center.x + Math.cos(a) * outerR;\n const y2 = center.y + Math.sin(a) * outerR;\n ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();\n }\n ctx.globalAlpha = 1;\n }\n\n if (opts?.bevel) {\n // 浮雕：内外圈高光/暗部描边\n ctx.lineWidth = Math.max(1, (outerR - innerR) * 0.06);\n ctx.strokeStyle = '#ffffff22';\n ctx.beginPath(); ctx.arc(center.x, center.y, outerR * 0.98, 0, Math.PI * 2); ctx.stroke();\n ctx.strokeStyle = '#00000066';\n ctx.beginPath(); ctx.arc(center.x, center.y, innerR * 1.02, 0, Math.PI * 2); ctx.stroke();\n }\n ctx.restore();\n}\n\nexport function drawGlowArc(\n ctx: CanvasRenderingContext2D,\n center: Point,\n radius: number, // 画布像素（已含 DPR）\n progress: number, // 0..1，动画相位\n theme: Theme\n) {\n // 高光弧随时间旋转，模拟“磁环”流动高光\n const start = progress * Math.PI * 2;\n const end = start + Math.PI * 0.5; // 90° 高光段\n const grad = ctx.createConicGradient(start, center.x, center.y);\n grad.addColorStop(0, '#ffffff66');\n grad.addColorStop(0.5, theme.palette.accent + '99');\n grad.addColorStop(1, '#ffffff00');\n\n ctx.save();\n ctx.globalCompositeOperation = 'lighter';\n ctx.lineWidth = Math.max(2, radius * 0.06);\n ctx.strokeStyle = grad as unknown as string;\n ctx.beginPath();\n ctx.arc(center.x, center.y, radius, start, end);\n ctx.stroke();\n ctx.restore();\n}\n\n// =========================================\n// File: packages/luopan-react/src/Luopan.tsx (完整覆盖版，含飞星环/中心九宫/金属与磁环动画)\n// =========================================\n'use client';\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport type { Layer, Theme } from '@qiflow/luopan-core/types';\nimport { MOUNTAIN_24 } from '@qiflow/luopan-core/constants/24mountains';\nimport { BAGUA_POSTERIOR } from '@qiflow/luopan-core/constants/bagua';\nimport { metalAncient } from './theme/metalAncient';\nimport { drawLayers } from './renderers/canvasRenderer';\nimport { getDpr } from './utils/dpr';\nimport { computeFlyingStars } from '@qiflow/luopan-core/flyingStars';\nimport { drawFlyingStarOverlay } from './layers/flyingStarLayer';\nimport { buildFlyingStarRingLayer } from './layers/flyingStarRingLayer';\nimport { drawMetalBezel, drawGlowArc, isLowEndDevice } from './visual/metalEffects';\n\nexport interface LuopanProps {\n size?: number;\n angle?: number;\n theme?: Theme;\n dpiScale?: number;\n showFlyingStarOverlay?: boolean; // 中心九宫\n showFlyingStarRing?: boolean; // 外环\n}\n\nexport const Luopan: React.FC<LuopanProps> = ({\n size = 320,\n angle = 0,\n theme = metalAncient,\n dpiScale,\n showFlyingStarOverlay = true,\n showFlyingStarRing = false,\n}) => {\n const canvasRef = useRef<HTMLCanvasElement | null>(null);\n const dpr = getDpr(dpiScale);\n const [t, setT] = useState(0); // 动画相位 0..1\n\n const layers = useMemo<Layer[]>(() => {\n const base: Layer[] = [\n {\n id: 'layer-24mountains',\n name: '24山',\n ringWidth: size * 0.18,\n cells: MOUNTAIN_24,\n style: { ringFill: theme.palette.ring, textFill: theme.palette.text, font: `600 ${Math.floor(size * 0.055)}px 'Noto Serif SC', 'Songti SC', serif` },\n },\n {\n id: 'layer-bagua',\n name: '后天八卦',\n ringWidth: size * 0.12,\n cells: BAGUA_POSTERIOR,\n style: { ringFill: '#3b2f1b', textFill: theme.palette.accent, font: `700 ${Math.floor(size * 0.06)}px 'Noto Serif SC', serif` },\n },\n ];\n\n if (showFlyingStarRing) {\n const chart = computeFlyingStars({ facingDeg: angle, year: new Date().getFullYear() });\n base.unshift(buildFlyingStarRingLayer(chart, { ringWidth: size * 0.12, showAnnual: true, showMonthly: true }));\n }\n return base;\n }, [size, theme, angle, showFlyingStarRing]);\n\n useEffect(() => {\n const canvas = canvasRef.current;\n if (!canvas) return;\n\n const logical = size;\n const radius = logical / 2 - Math.floor(logical * 0.04);\n\n canvas.width = Math.floor(logical * dpr);\n canvas.height = Math.floor(logical * dpr);\n canvas.style.width = `${logical}px`;\n canvas.style.height = `${logical}px`;\n\n const ctx = canvas.getContext('2d');\n if (!ctx) return;\n\n // 背景\n ctx.clearRect(0, 0, canvas.width, canvas.height);\n ctx.fillStyle = theme.palette.bg;\n ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n const cx = (canvas.width) / 2;\n const cy = (canvas.height) / 2;\n\n // 金属外圈（固定在屏幕坐标，不随罗盘旋转）\n const bezelOuter = radius * dpr + Math.max(8, dpr * 6);\n const bezelInner = radius * dpr - Math.max(6, dpr * 4);\n drawMetalBezel(ctx, { x: cx, y: cy }, bezelOuter, bezelInner, theme, { brushed: !isLowEndDevice(), bevel: true });\n\n // 盘面旋转层\n ctx.save();\n ctx.translate(cx, cy);\n ctx.rotate((angle * Math.PI) / 180);\n ctx.translate(-cx, -cy);\n\n drawLayers(\n {\n ctx,\n center: { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 },\n radius,\n dpr,\n theme,\n rotationDeg: angle,\n },\n layers\n );\n ctx.restore();\n\n // 中心“磁环”高光弧（动画）\n if (!isLowEndDevice()) {\n drawGlowArc(ctx, { x: cx, y: cy }, Math.max(10, radius * dpr * 0.14), t, theme);\n }\n\n // 中心九宫覆盖\n if (showFlyingStarOverlay) {\n const chart = computeFlyingStars({ facingDeg: angle, year: new Date().getFullYear() });\n drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });\n }\n }, [size, dpr, angle, theme, layers, t, showFlyingStarOverlay]);\n\n // 动画时钟（仅高端机启用）\n useEffect(() => {\n if (isLowEndDevice()) return; // 降级：关闭动画\n let raf = 0;\n let running = true;\n const tick = () => {\n setT(prev => (prev + 0.012) % 1);\n if (running) raf = requestAnimationFrame(tick);\n };\n raf = requestAnimationFrame(tick);\n return () => { running = false; cancelAnimationFrame(raf); };\n }, []);\n\n return <canvas ref={canvasRef} aria-label=\"Luopan Compass\" />;\n};\n\nexport default Luopan;\n"}
```
搞定 ✅  
我已经把你要的三块内容全部加到右侧画布里了（可直接拷到仓库里用）：

1) **更严谨的飞星推算表**  
`packages/luopan-core/src/constants/flyingStarTables.ts`  
- 提供九运起止年区间、洛书顺/逆飞模板、面向度象限→顺逆的规则函数（方便以后替换为节气/立春精确切换）。

2) **飞星“外环”版本**  
`packages/luopan-react/src/layers/flyingStarRingLayer.ts`  
- 把九宫飞星映射为罗盘**外环**的 `Layer`，可与 24 山并列显示；支持是否显示“年星/月星”。

3) **金属拉丝 + 浮雕刻线 + 中心“磁环”动态高光弧**  
`packages/luopan-react/src/visual/metalEffects.ts`  
- `drawMetalBezel()`：外圈金属拉丝/浮雕（自动对低端机降级：关拉丝、保基本渐变与描边）。  
- `drawGlowArc()`：中心磁环高光弧动画。  
- `isLowEndDevice()`：简单启发式降级判断。

另外我把 **`Luopan.tsx` 完整升级版** 也放进去了（同一画布文件里）：
- 新增 props：`showFlyingStarOverlay`（中心九宫），`showFlyingStarRing`（外环）。
- 集成 `drawMetalBezel`、`drawGlowArc`，高端机开动画、低端机自动降级。
- `layers` 中按需 `unshift` 飞星外环；叠加中心九宫覆盖。

---

### 怎么用（最短指引）
在你的 Next.js 页面里（示例）：
```tsx
<Luopan
size={360}
angle={angle} // 你的朝向（跟设备或手动滑杆）
showFlyingStarRing // 开外环飞星
showFlyingStarOverlay // 开中心九宫
/>
```
若想只显示外环不显示中心九宫：把 `showFlyingStarOverlay={false}`。
飞星按当前年份简化推断九运；后续要按**立春/节气**精细切换，我再给你补“年月日交接表 + 插值函数”。

---

### 推荐下一步（任选）
- **数据精细化**：把“九运交接”从“公历年”换成“立春切换”，并补“月星交接表”。
- **主题皮肤**：在 `drawMetalBezel` 里再加“切面高光段数”和“拉丝方向随机扰动”，质感会更“器材级”。
- **手势旋转 Hook**：单指旋转 + 阻尼（之前我提过方案），要不要我直接加？
- **Storybook + 截图回归**：便于你做 UI 验收；我可以顺手写几个常用故事（24山、飞星外环、九宫覆盖、主题切换、设备方向模拟）。

需要我把**节气级的年/月星交接表**和**手势旋转 Hook**也落进去吗？你说一声，我马上补上。

---
## 🧑‍💻 User

好的，你说的都加上

---
## 🤖 Assistant

> *Thought for 23s*


```json
{"updates":[{"pattern":"\\Z","replacement":"\n\n// =========================================\n// File: packages/luopan-core/src/constants/jieqi.ts\n// 节气近似表（原型版）：用于年/月份界点（立春切换年星，月建近似按节中切换）\n// 说明：为便于前端离线计算，这里提供“平均节气日”近似法：\n// - 立春 ~ 公历 2 月 4 日（±1 天），作为年星切换点（上一年 → 新一年）\n// - 月星切换：每月以“节气”或“中气”当天 00:00 UTC 作为近似界点\n// 注意：生产中建议以后端天文历法服务返回精确时间（时区敏感）。\n// =========================================\nexport const APPROX_LICHUN_MONTH = 2; // 2 月\nexport const APPROX_LICHUN_DAY = 4; // 4 日（±1 天）\n\n// 24 节气（从小寒开始）近似在公历中的发生日（UTC，原型用）\n// 索引与常见顺序一致：小寒、大寒、立春、雨水、惊蛰、春分、清明、谷雨、立夏、小满、芒种、夏至、\n// 小暑、大暑、立秋、处暑、白露、秋分、寒露、霜降、立冬、小雪、大雪、冬至。\nexport const JIEQI_APPROX_DAY = [\n [1,6], [1,20], [2,4], [2,19], [3,6], [3,21],\n [4,5], [4,20], [5,6], [5,21], [6,6], [6,21],\n [7,7], [7,23], [8,8], [8,23], [9,8], [9,23],\n [10,8], [10,23],[11,7], [11,22],[12,7], [12,22],\n] as const; // [month, day]\n\n// 每月用于月星切换的“节/中气”近似日期：\n// 这里取“节（上旬）或中气（下旬）”之一，保证每月 1 次切换。\n// 例如：正月以立春、二月以惊蛰、三月以清明……\nexport const MONTH_BOUNDARY_APPROX: ReadonlyArray<[month:number, day:number]> = [\n [1,20], // 大寒附近（上一年十二月至次年正月的边界已由立春处理，这里用于月星序列）\n [2,4], // 立春\n [3,6], // 惊蛰\n [4,5], // 清明\n [5,6], // 立夏\n [6,6], // 芒种\n [7,7], // 小暑\n [8,8], // 立秋\n [9,8], // 白露\n [10,8], // 寒露\n [11,7], // 立冬\n [12,7], // 大雪\n];\n\n// =========================================\n// File: packages/luopan-core/src/jieqiBoundaries.ts\n// 年/月份界点计算（原型版）：\n// - 年星：以立春（约 2 月 4 日 00:00 UTC）为界；立春前仍算上一年\n// - 月星：每月按 MONTH_BOUNDARY_APPROX 指定日期切换\n// =========================================\nimport { APPROX_LICHUN_DAY, APPROX_LICHUN_MONTH, MONTH_BOUNDARY_APPROX } from './constants/jieqi';\n\nexport function splitYearByLichun(date: Date): { fengshuiYear: number } {\n const y = date.getUTCFullYear();\n const lichun = Date.UTC(y, APPROX_LICHUN_MONTH - 1, APPROX_LICHUN_DAY, 0, 0, 0);\n const ts = date.getTime();\n if (ts < lichun) return { fengshuiYear: y - 1 };\n return { fengshuiYear: y };\n}\n\nexport function monthIdxByBoundary(date: Date): number {\n // 返回 1..12 的“风水月序”，按 boundary 近似\n const y = date.getUTCFullYear();\n const m = date.getUTCMonth() + 1;\n const d = date.getUTCDate();\n const boundary = MONTH_BOUNDARY_APPROX.find(([mm]) => mm === m)!;\n const boundaryTs = Date.UTC(y, boundary[^0]-1, boundary[^1], 0, 0, 0);\n const ts = date.getTime();\n const idx = ts >= boundaryTs ? m : (m === 1 ? 12 : m - 1);\n return idx; // 1..12\n}\n\n// =========================================\n// File: packages/luopan-core/src/flyingStars.ts (PATCH 增强：按立春与月界切换推断年/月星)\n// =========================================\n/* PATCH START */\nimport { splitYearByLichun, monthIdxByBoundary } from './jieqiBoundaries';\n\nexport interface BoundaryStrategy {\n useLichunForYear?: boolean; // 默认 true\n useMonthlyBoundary?: boolean; // 默认 true\n}\n\nexport function computeFlyingStars(\n params: FlyingStarParams & { boundaryStrategy?: BoundaryStrategy }\n): FlyingStarChart {\n const bs = params.boundaryStrategy ?? { useLichunForYear: true, useMonthlyBoundary: true };\n\n // 推断 period（九运）\n let periodYear = params.year;\n let annualYear = params.year;\n let monthForCalc: number | undefined;\n\n const date = params.dateISO ? new Date(params.dateISO) : undefined;\n if (date) {\n if (bs.useLichunForYear) {\n const { fengshuiYear } = splitYearByLichun(date);\n periodYear = fengshuiYear;\n annualYear = fengshuiYear;\n } else {\n annualYear = date.getUTCFullYear();\n periodYear = params.year ?? annualYear;\n }\n if (bs.useMonthlyBoundary) {\n monthForCalc = monthIdxByBoundary(date);\n } else {\n monthForCalc = date.getUTCMonth() + 1;\n }\n }\n\n const period = params.period ?? inferPeriodByYear(periodYear);\n const base = computeBaseChart(period, params.facingDeg);\n const grid = buildMountainFacing(base, params.facingDeg, params.sittingDeg);\n\n const annual = computeAnnualStar(annualYear);\n const monthly = computeMonthlyStar(annualYear, monthForCalc);\n\n const enriched = grid.map(cell => ({ ...cell, annual, monthly })) as NineCells<FlyingStarChartCell>;\n return { period, grid: enriched };\n}\n/* PATCH END */\n\n// =========================================\n// File: packages/luopan-react/src/hooks/useDragRotate.ts\n// 单指/鼠标拖拽旋转 Hook（带阻尼与吸附），移动端优先\n// =========================================\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nexport interface DragRotateOptions {\n enabled?: boolean;\n initialAngle?: number; // 初始角度\n damping?: number; // 0..1，阻尼系数，默认 0.92\n snapStepDeg?: number; // 吸附步进（例如 15°）\n}\n\nexport function useDragRotate(\n targetRef: React.RefObject<HTMLElement>,\n opts: DragRotateOptions = {}\n) {\n const { enabled = true, initialAngle = 0, damping = 0.92, snapStepDeg } = opts;\n const [angle, setAngle] = useState(initialAngle);\n const velRef = useRef(0); // 惯性角速度（deg/frame）\n const raf = useRef(0);\n\n const polarDeg = (cx: number, cy: number, x: number, y: number) => {\n const dx = x - cx; const dy = y - cy; return (Math.atan2(dy, dx) * 180) / Math.PI;\n };\n\n useEffect(() => {\n if (!enabled) return;\n const el = targetRef.current; if (!el) return;\n let dragging = false; let prevDeg = 0; let center = { x: 0, y: 0 };\n\n const start = (clientX: number, clientY: number) => {\n const rect = el.getBoundingClientRect();\n center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };\n prevDeg = polarDeg(center.x, center.y, clientX, clientY);\n dragging = true; velRef.current = 0;\n };\n const move = (clientX: number, clientY: number) => {\n if (!dragging) return;\n const now = polarDeg(center.x, center.y, clientX, clientY);\n let delta = now - prevDeg;\n // 规范化 -180..180\n delta = ((delta + 180) % 360) - 180;\n prevDeg = now;\n setAngle(a => a + delta);\n velRef.current = delta; // 记录瞬时速度\n };\n const end = () => { dragging = false; };\n\n const onMouseDown = (e: MouseEvent) => { e.preventDefault(); start(e.clientX, e.clientY); };\n const onMouseMove = (e: MouseEvent) => move(e.clientX, e.clientY);\n const onMouseUp = () => end();\n\n const onTouchStart = (e: TouchEvent) => {\n if (e.touches.length !== 1) return; const t = e.touches[^0]; start(t.clientX, t.clientY);\n };\n const onTouchMove = (e: TouchEvent) => {\n if (e.touches.length !== 1) return; const t = e.touches[^0]; move(t.clientX, t.clientY);\n };\n const onTouchEnd = () => end();\n\n el.addEventListener('mousedown', onMouseDown);\n window.addEventListener('mousemove', onMouseMove);\n window.addEventListener('mouseup', onMouseUp);\n\n el.addEventListener('touchstart', onTouchStart, { passive: false });\n window.addEventListener('touchmove', onTouchMove, { passive: false });\n window.addEventListener('touchend', onTouchEnd);\n\n // 惯性滚动 + 阻尼\n let running = true; const tick = () => {\n if (!dragging && Math.abs(velRef.current) > 0.01) {\n setAngle(a => a + velRef.current);\n velRef.current *= damping;\n }\n raf.current = requestAnimationFrame(tick);\n };\n raf.current = requestAnimationFrame(tick);\n\n return () => {\n running = false; cancelAnimationFrame(raf.current);\n el.removeEventListener('mousedown', onMouseDown);\n window.removeEventListener('mousemove', onMouseMove);\n window.removeEventListener('mouseup', onMouseUp);\n el.removeEventListener('touchstart', onTouchStart);\n window.removeEventListener('touchmove', onTouchMove);\n window.removeEventListener('touchend', onTouchEnd);\n };\n }, [enabled, targetRef, damping]);\n\n // 吸附\n const snapped = ((): number => {\n if (!snapStepDeg) return angle;\n const step = snapStepDeg;\n const a = ((angle % 360) + 360) % 360;\n const k = Math.round(a / step) * step;\n return k;\n })();\n\n return { angle: snapped, setAngle };\n}\n\n// =========================================\n// File: packages/luopan-react/src/Luopan.tsx (PATCH：接入拖拽旋转与节气边界飞星)\n// =========================================\n/* PATCH START */\nimport { useDragRotate } from './hooks/useDragRotate';\n\nexport interface LuopanProps {\n size?: number;\n angle?: number; // 受控优先\n theme?: Theme;\n dpiScale?: number;\n showFlyingStarOverlay?: boolean;\n showFlyingStarRing?: boolean;\n interactive?: boolean; // 开启后可拖拽旋转\n}\n\nexport const Luopan: React.FC<LuopanProps> = ({\n size = 320,\n angle,\n theme = metalAncient,\n dpiScale,\n showFlyingStarOverlay = true,\n showFlyingStarRing = false,\n interactive = true,\n}) => {\n const canvasRef = useRef<HTMLCanvasElement | null>(null);\n const dpr = getDpr(dpiScale);\n const [t, setT] = useState(0);\n const { angle: dragAngle, setAngle: setDragAngle } = useDragRotate(canvasRef, { enabled: interactive, snapStepDeg: 1 });\n\n const effectiveAngle = (typeof angle === 'number') ? angle : dragAngle;\n\n const layers = useMemo<Layer[]>(() => {\n const base: Layer[] = [\n {\n id: 'layer-24mountains', name: '24山', ringWidth: size * 0.18, cells: MOUNTAIN_24,\n style: { ringFill: theme.palette.ring, textFill: theme.palette.text, font: `600 ${Math.floor(size * 0.055)}px 'Noto Serif SC', 'Songti SC', serif` },\n },\n {\n id: 'layer-bagua', name: '后天八卦', ringWidth: size * 0.12, cells: BAGUA_POSTERIOR,\n style: { ringFill: '#3b2f1b', textFill: theme.palette.accent, font: `700 ${Math.floor(size * 0.06)}px 'Noto Serif SC', serif` },\n },\n ];\n if (showFlyingStarRing) {\n const chart = computeFlyingStars({\n facingDeg: effectiveAngle,\n dateISO: new Date().toISOString(),\n boundaryStrategy: { useLichunForYear: true, useMonthlyBoundary: true },\n });\n base.unshift(buildFlyingStarRingLayer(chart, { ringWidth: size * 0.12, showAnnual: true, showMonthly: true }));\n }\n return base;\n }, [size, theme, effectiveAngle, showFlyingStarRing]);\n\n useEffect(() => {\n const canvas = canvasRef.current; if (!canvas) return;\n const logical = size; const radius = logical / 2 - Math.floor(logical * 0.04);\n canvas.width = Math.floor(logical * dpr); canvas.height = Math.floor(logical * dpr);\n canvas.style.width = `${logical}px`; canvas.style.height = `${logical}px`;\n const ctx = canvas.getContext('2d'); if (!ctx) return;\n\n // 背景\n ctx.clearRect(0, 0, canvas.width, canvas.height);\n ctx.fillStyle = theme.palette.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n const cx = (canvas.width) / 2; const cy = (canvas.height) / 2;\n\n // 金属外圈\n const bezelOuter = radius * dpr + Math.max(8, dpr * 6);\n const bezelInner = radius * dpr - Math.max(6, dpr * 4);\n drawMetalBezel(ctx, { x: cx, y: cy }, bezelOuter, bezelInner, theme, { brushed: !isLowEndDevice(), bevel: true });\n\n // 旋转层\n ctx.save(); ctx.translate(cx, cy); ctx.rotate((effectiveAngle * Math.PI) / 180); ctx.translate(-cx, -cy);\n drawLayers({ ctx, center: { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 }, radius, dpr, theme, rotationDeg: effectiveAngle }, layers);\n ctx.restore();\n\n // 磁环高光\n if (!isLowEndDevice()) drawGlowArc(ctx, { x: cx, y: cy }, Math.max(10, radius * dpr * 0.14), t, theme);\n\n // 中心九宫\n if (showFlyingStarOverlay) {\n const chart = computeFlyingStars({\n facingDeg: effectiveAngle,\n dateISO: new Date().toISOString(),\n boundaryStrategy: { useLichunForYear: true, useMonthlyBoundary: true },\n });\n drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });\n }\n }, [size, dpr, theme, layers, t, showFlyingStarOverlay, effectiveAngle]);\n\n useEffect(() => {\n if (isLowEndDevice()) return; let raf = 0; let running = true;\n const tick = () => { setT(prev => (prev + 0.012) % 1); if (running) raf = requestAnimationFrame(tick); };\n raf = requestAnimationFrame(tick); return () => { running = false; cancelAnimationFrame(raf); };\n }, []);\n\n return <canvas ref={canvasRef} aria-label=\"Luopan Compass\" />;\n};\n/* PATCH END */\n"}]}
```

```json
{"name":"QiFlow Luopan – 节气边界+拖拽旋转+金属磁环 完整增补包","type":"code/react","content":"// =========================================\n// File: packages/luopan-core/src/constants/jieqi.ts\n// 节气近似表（原型版）：用于年/月份界点（立春切换年星，月建近似按节中切换）\n// 说明：为便于前端离线计算，这里提供“平均节气日”近似法：\n// - 立春 ~ 公历 2 月 4 日（±1 天），作为年星切换点（上一年 → 新一年）\n// - 月星切换：每月以“节气”或“中气”当天 00:00 UTC 作为近似界点\n// 注意：生产中建议以后端天文历法服务返回精确时间（时区敏感）。\n// =========================================\nexport const APPROX_LICHUN_MONTH = 2; // 2 月\nexport const APPROX_LICHUN_DAY = 4; // 4 日（±1 天）\n\n// 24 节气（从小寒开始）近似在公历中的发生日（UTC，原型用）\n// 索引与常见顺序一致：小寒、大寒、立春、雨水、惊蛰、春分、清明、谷雨、立夏、小满、芒种、夏至、\n// 小暑、大暑、立秋、处暑、白露、秋分、寒露、霜降、立冬、小雪、大雪、冬至。\nexport const JIEQI_APPROX_DAY = [\n [1,6], [1,20], [2,4], [2,19], [3,6], [3,21],\n [4,5], [4,20], [5,6], [5,21], [6,6], [6,21],\n [7,7], [7,23], [8,8], [8,23], [9,8], [9,23],\n [10,8], [10,23],[11,7], [11,22],[12,7], [12,22],\n] as const; // [month, day]\n\n// 每月用于月星切换的“节/中气”近似日期：\n// 这里取“节（上旬）或中气（下旬）”之一，保证每月 1 次切换。\n// 例如：正月以立春、二月以惊蛰、三月以清明……\nexport const MONTH_BOUNDARY_APPROX: ReadonlyArray<[month:number, day:number]> = [\n [1,20], // 大寒附近（上一年十二月至次年正月的边界已由立春处理，这里用于月星序列）\n [2,4], // 立春\n [3,6], // 惊蛰\n [4,5], // 清明\n [5,6], // 立夏\n [6,6], // 芒种\n [7,7], // 小暑\n [8,8], // 立秋\n [9,8], // 白露\n [10,8], // 寒露\n [11,7], // 立冬\n [12,7], // 大雪\n];\n\n\n// =========================================\n// File: packages/luopan-core/src/jieqiBoundaries.ts\n// 年/月份界点计算（原型版）：\n// - 年星：以立春（约 2 月 4 日 00:00 UTC）为界；立春前仍算上一年\n// - 月星：每月按 MONTH_BOUNDARY_APPROX 指定日期切换\n// =========================================\nimport { APPROX_LICHUN_DAY, APPROX_LICHUN_MONTH, MONTH_BOUNDARY_APPROX } from './constants/jieqi';\n\nexport function splitYearByLichun(date: Date): { fengshuiYear: number } {\n const y = date.getUTCFullYear();\n const lichun = Date.UTC(y, APPROX_LICHUN_MONTH - 1, APPROX_LICHUN_DAY, 0, 0, 0);\n const ts = date.getTime();\n if (ts < lichun) return { fengshuiYear: y - 1 };\n return { fengshuiYear: y };\n}\n\nexport function monthIdxByBoundary(date: Date): number {\n // 返回 1..12 的“风水月序”，按 boundary 近似\n const y = date.getUTCFullYear();\n const m = date.getUTCMonth() + 1;\n const boundary = MONTH_BOUNDARY_APPROX.find(([mm]) => mm === m)!;\n const boundaryTs = Date.UTC(y, boundary[^0]-1, boundary[^1], 0, 0, 0);\n const ts = date.getTime();\n const idx = ts >= boundaryTs ? m : (m === 1 ? 12 : m - 1);\n return idx; // 1..12\n}\n\n\n// =========================================\n// File: packages/luopan-core/src/constants/flyingStarTables.ts\n// 更严谨的飞星推算表（原型级）：九运起止年、洛书宫序、顺逆飞映射等\n// 备注：真实流派在交接年/节气点上存在差异，本表按通用20年一运、\n// 以公历年粗分（可在生产中按节令/立春切分）。\n// =========================================\nexport interface PeriodSpan { period: 1|2|3|4|5|6|7|8|9; startYear: number; endYear: number }\nexport const PERIOD_SPANS: PeriodSpan[] = [\n { period:1, startYear:1864, endYear:1883 },\n { period:2, startYear:1884, endYear:1903 },\n { period:3, startYear:1904, endYear:1923 },\n { period:4, startYear:1924, endYear:1943 },\n { period:5, startYear:1944, endYear:1963 },\n { period:6, startYear:1964, endYear:1983 },\n { period:7, startYear:1984, endYear:2003 },\n { period:8, startYear:2004, endYear:2023 },\n { period:9, startYear:2024, endYear:2043 },\n];\n\nexport const LO_SHU_INDEX_TO_DIRECTION = [\n '西北','北','东北',\n '西','中','东',\n '西南','南','东南',\n];\n\nexport const LO_SHU_SEQ_FORWARD = [\n 8,1,6, 3,5,7, 4,9,2,\n] as const;\n\nexport const LO_SHU_SEQ_BACKWARD = [\n 2,9,4, 7,5,3, 6,1,8,\n] as const;\n\nexport function isForwardByFacingDeg(deg: number): boolean {\n const d = ((deg % 360) + 360) % 360;\n return d >= 45 && d < 225; // 面东/南象限 → 顺飞\n}\n\n\n// =========================================\n// File: packages/luopan-core/src/flyingStars.ts (增强：按立春与月界切换推断年/月星)\n// =========================================\nimport type { Degree } from './types';\nimport { splitYearByLichun, monthIdxByBoundary } from './jieqiBoundaries';\n\nexport type NineCells<T = number> = [T, T, T, T, T, T, T, T, T];\n\nexport interface FlyingStarParams {\n period?: 1|2|3|4|5|6|7|8|9;\n year?: number;\n facingDeg: Degree;\n sittingDeg?: Degree;\n dateISO?: string;\n}\n\nexport interface BoundaryStrategy {\n useLichunForYear?: boolean; // 默认 true\n useMonthlyBoundary?: boolean; // 默认 true\n}\n\nexport interface FlyingStarChartCell {\n mountain: number; facing: number; annual?: number; monthly?: number;\n}\nexport interface FlyingStarChart {\n period: 1|2|3|4|5|6|7|8|9; grid: NineCells<FlyingStarChartCell>;\n}\n\nconst degNorm = (d: number) => ((d % 360) + 360) % 360;\n\nexport function inferPeriodByYear(year?: number): 1|2|3|4|5|6|7|8|9 {\n if (!year) return 9; if (year >= 2024 && year <= 2043) return 9; if (year >= 2004 && year <= 2023) return 8; if (year >= 1984 && year <= 2003) return 7;\n const base = 1864; const diff = Math.floor((year! - base) / 20); return (((diff % 9) + 9) % 9 + 1) as 1|2|3|4|5|6|7|8|9;\n}\n\nexport function computeBaseChart(period: 1|2|3|4|5|6|7|8|9, facingDeg: Degree): NineCells<number> {\n const seqF: NineCells<number> = [8,1,6,3,5,7,4,9,2];\n const seqB: NineCells<number> = [2,9,4,7,5,3,6,1,8];\n const forward = (degNorm(facingDeg) >= 45 && degNorm(facingDeg) < 225);\n const base = forward ? seqF : seqB;\n const shift = ((period - 5) + 9) % 9; // 把中宫 5 映射到 period\n const remap = base.map(n => ((n + shift -1) % 9) + 1) as NineCells<number>;\n remap[^4] = period; return remap;\n}\n\nexport function degToLoShuIndex(deg: Degree): number {\n const d = degNorm(deg);\n const sectors: {range:[number,number], idx:number}[] = [\n { range:[337.5, 360], idx:1 },{ range:[0,22.5], idx:1 },\n { range:[22.5,67.5], idx:2 }, { range:[67.5,112.5], idx:5 }, { range:[112.5,157.5], idx:8 },\n { range:[157.5,202.5], idx:7 }, { range:[202.5,247.5], idx:6 }, { range:[247.5,292.5], idx:3 }, { range:[292.5,337.5], idx:0 },\n ];\n const hit = sectors.find(s => (d >= s.range[^0] && d < s.range[^1]) || (s.range[^0] > s.range[^1] && (d>=s.range[^0] || d<s.range[^1])));\n return hit ? hit.idx : 4;\n}\n\nexport function buildMountainFacing(base: NineCells<number>, facingDeg: Degree, sittingDeg?: Degree): NineCells<FlyingStarChartCell> {\n const sit = sittingDeg ?? degNorm(facingDeg + 180);\n const facingIdx = degToLoShuIndex(facingDeg); const sittingIdx = degToLoShuIndex(sit);\n const grid = base.map((n) => ({ mountain: n, facing: n })) as NineCells<FlyingStarChartCell>;\n grid[facingIdx].facing = ((grid[facingIdx].facing) % 9) + 1; grid[sittingIdx].mountain = ((grid[sittingIdx].mountain) % 9) + 1; return grid;\n}\n\nexport function computeAnnualStar(year?: number): number | undefined {\n if (!year) return undefined; const base = 2024; const n = ((year - base) % 9 + 9) % 9; return ((9 - n - 1) % 9) + 1;\n}\nexport function computeMonthlyStar(year?: number, month?: number): number | undefined {\n if (!year || !month) return undefined; const offset = ((year * 12 + month) - (2024 * 12 + 1)); const n = ((offset % 9) + 9) % 9; return ((9 - n - 1) % 9) + 1;\n}\n\nexport function computeFlyingStars(\n params: FlyingStarParams & { boundaryStrategy?: BoundaryStrategy }\n): FlyingStarChart {\n const bs = params.boundaryStrategy ?? { useLichunForYear: true, useMonthlyBoundary: true };\n let periodYear = params.year; let annualYear = params.year; let monthForCalc: number | undefined;\n const date = params.dateISO ? new Date(params.dateISO) : undefined;\n if (date) {\n if (bs.useLichunForYear) { const { fengshuiYear } = splitYearByLichun(date); periodYear = fengshuiYear; annualYear = fengshuiYear; }\n else { annualYear = date.getUTCFullYear(); periodYear = params.year ?? annualYear; }\n monthForCalc = bs.useMonthlyBoundary ? monthIdxByBoundary(date) : (date.getUTCMonth() + 1);\n }\n const period = params.period ?? inferPeriodByYear(periodYear);\n const base = computeBaseChart(period, params.facingDeg);\n const grid = buildMountainFacing(base, params.facingDeg, params.sittingDeg);\n const annual = computeAnnualStar(annualYear); const monthly = computeMonthlyStar(annualYear, monthForCalc);\n const enriched = grid.map(cell => ({ ...cell, annual, monthly })) as NineCells<FlyingStarChartCell>;\n return { period, grid: enriched };\n}\n\n\n// =========================================\n// File: packages/luopan-react/src/hooks/useDragRotate.ts\n// 单指/鼠标拖拽旋转 Hook（带阻尼与吸附），移动端优先\n// =========================================\nimport { useEffect, useRef, useState } from 'react';\n\nexport interface DragRotateOptions { enabled?: boolean; initialAngle?: number; damping?: number; snapStepDeg?: number; }\n\nexport function useDragRotate(targetRef: React.RefObject<HTMLElement>, opts: DragRotateOptions = {}) {\n const { enabled = true, initialAngle = 0, damping = 0.92, snapStepDeg } = opts;\n const [angle, setAngle] = useState(initialAngle);\n const velRef = useRef(0); const raf = useRef(0);\n const polarDeg = (cx:number, cy:number, x:number, y:number) => (Math.atan2(y - cy, x - cx) * 180) / Math.PI;\n\n useEffect(() => {\n if (!enabled) return; const el = targetRef.current; if (!el) return;\n let dragging = false; let prevDeg = 0; let center = { x: 0, y: 0 };\n const start = (clientX:number, clientY:number) => { const rect = el.getBoundingClientRect(); center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 }; prevDeg = polarDeg(center.x, center.y, clientX, clientY); dragging = true; velRef.current = 0; };\n const move = (clientX:number, clientY:number) => { if (!dragging) return; const now = polarDeg(center.x, center.y, clientX, clientY); let delta = now - prevDeg; delta = ((delta + 180) % 360) - 180; prevDeg = now; setAngle(a => a + delta); velRef.current = delta; };\n const end = () => { dragging = false; };\n const onMouseDown = (e:MouseEvent)=>{ e.preventDefault(); start(e.clientX, e.clientY); };\n const onMouseMove = (e:MouseEvent)=> move(e.clientX, e.clientY);\n const onMouseUp = ()=> end();\n const onTouchStart = (e:TouchEvent)=>{ if (e.touches.length!==1) return; const t=e.touches[^0]; start(t.clientX,t.clientY); };\n const onTouchMove = (e:TouchEvent)=>{ if (e.touches.length!==1) return; const t=e.touches[^0]; move(t.clientX,t.clientY); };\n const onTouchEnd = ()=> end();\n el.addEventListener('mousedown', onMouseDown);\n window.addEventListener('mousemove', onMouseMove);\n window.addEventListener('mouseup', onMouseUp);\n el.addEventListener('touchstart', onTouchStart, { passive: false });\n window.addEventListener('touchmove', onTouchMove, { passive: false });\n window.addEventListener('touchend', onTouchEnd);\n const tick = () => { if (!dragging && Math.abs(velRef.current) > 0.01) { setAngle(a => a + velRef.current); velRef.current *= damping; } raf.current = requestAnimationFrame(tick); };\n raf.current = requestAnimationFrame(tick);\n return () => { cancelAnimationFrame(raf.current); el.removeEventListener('mousedown', onMouseDown); window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); el.removeEventListener('touchstart', onTouchStart); window.removeEventListener('touchmove', onTouchMove); window.removeEventListener('touchend', onTouchEnd); };\n }, [enabled, targetRef, damping]);\n\n const snapped = (() => { if (!snapStepDeg) return angle; const step = snapStepDeg; const a = ((angle % 360) + 360) % 360; return Math.round(a / step) * step; })();\n return { angle: snapped, setAngle };\n}\n\n\n// =========================================\n// File: packages/luopan-react/src/layers/flyingStarRingLayer.ts\n// 将飞星盘映射为“外环”Layer，可与24山并列显示\n// =========================================\nimport type { Layer, Cell } from '@qiflow/luopan-core/types';\nimport type { FlyingStarChart } from '@qiflow/luopan-core/flyingStars';\n\nconst LO_SHU_INDEX_TO_DEG: number[] = [ 315, 0, 45, 270, 999, 90, 225, 180, 135 ];\n\nexport interface FlyingStarRingOptions { ringWidth: number; startAngle?: number; clockwise?: boolean; showAnnual?: boolean; showMonthly?: boolean; }\n\nexport function buildFlyingStarRingLayer(chart: FlyingStarChart, opts: FlyingStarRingOptions): Layer {\n const cells: Cell[] = [];\n for (let i = 0; i < 9; i++) {\n const center = LO_SHU_INDEX_TO_DEG[i]; if (center === 999) continue; const span = 40;\n const startDeg = ((center - span/2) + 360) % 360; const endDeg = ((center + span/2) + 360) % 360;\n const g = chart.grid[i]; const label = `${g.mountain}/${g.facing}` + ((opts.showAnnual && g.annual) ? `·年${g.annual}` : '') + ((opts.showMonthly && g.monthly) ? `·月${g.monthly}` : '');\n cells.push({ label, startDeg, endDeg, meta: { idx: i } });\n }\n return { id: 'layer-flying-star-ring', name: '飞星环', ringWidth: opts.ringWidth, startAngle: opts.startAngle ?? 0, clockwise: opts.clockwise ?? true, cells, style: { ringFill: '#2a2216', textFill: '#f0d9a1', font: `700 ${Math.max(10, Math.floor(opts.ringWidth * 0.28))}px 'Noto Serif SC', serif` } };\n}\n\n\n// =========================================\n// File: packages/luopan-react/src/layers/flyingStarOverlay.ts\n// 中心九宫覆盖绘制（与之前版本等价，文件名便于区分）\n// =========================================\nimport type { Theme } from '@qiflow/luopan-core/types';\nimport type { FlyingStarChart } from '@qiflow/luopan-core/flyingStars';\n\nexport interface FlyingStarOverlayOptions { size: number; dpr: number; theme: Theme; }\n\nexport function drawFlyingStarOverlay(ctx: CanvasRenderingContext2D, chart: FlyingStarChart, opts: FlyingStarOverlayOptions) {\n const { size, dpr, theme } = opts; const cell = Math.floor((size * 0.6) / 3); const start = Math.floor((size - cell * 3) / 2);\n ctx.save(); ctx.scale(dpr, dpr); ctx.strokeStyle = theme.palette.ring; ctx.lineWidth = Math.max(1, 1.2 * dpr); ctx.fillStyle = theme.palette.text; ctx.font = `700 ${Math.floor(cell * 0.28)}px 'Noto Serif SC', serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';\n for (let r = 0; r < 3; r++) { for (let c = 0; c < 3; c++) { const x = start + c * cell; const y = start + r * cell; ctx.strokeRect(x, y, cell, cell); const idx = r * 3 + c; const g = chart.grid[idx]; const line1 = `${g.mountain}/${g.facing}`; const line2 = `${g.annual ?? ''}${g.monthly ? '/' + g.monthly : ''}`; ctx.fillText(line1, x + cell / 2, y + cell * 0.42); if (line2) ctx.fillText(line2, x + cell / 2, y + cell * 0.72); } }\n ctx.fillStyle = theme.palette.accent; ctx.font = `800 ${Math.floor(cell * 0.32)}px 'Noto Serif SC', serif`; ctx.fillText(`运${chart.period}`, size / 2, start + cell * 1.5); ctx.restore();\n}\n\n\n// =========================================\n// File: packages/luopan-react/src/visual/metalEffects.ts\n// 金属外圈（拉丝/浮雕）与中心“磁环”动态高光弧；含低端机降级策略\n// =========================================\nimport type { Theme, Point } from '@qiflow/luopan-core/types';\n\nexport function isLowEndDevice(): boolean {\n if (typeof navigator === 'undefined') return false; const cores = (navigator as any).hardwareConcurrency ?? 4; const mem = (navigator as any).deviceMemory ?? 4; return cores <= 4 || mem <= 4;\n}\n\nexport function drawMetalBezel(ctx: CanvasRenderingContext2D, center: Point, outerR: number, innerR: number, theme: Theme, opts?: { brushed?: boolean; bevel?: boolean }) {\n const g = ctx.createRadialGradient(center.x, center.y, innerR, center.x, center.y, outerR);\n g.addColorStop(0.0, '#3a2c18'); g.addColorStop(0.45, theme.palette.ring); g.addColorStop(0.85, '#6e532f'); g.addColorStop(1.0, '#1a130b');\n ctx.save(); ctx.beginPath(); ctx.arc(center.x, center.y, outerR, 0, Math.PI * 2); ctx.arc(center.x, center.y, innerR, 0, Math.PI * 2, true); ctx.closePath(); ctx.fillStyle = g; ctx.fill();\n if (opts?.brushed) { const strokes = isLowEndDevice() ? 0 : Math.max(20, Math.floor((outerR - innerR) / 3)); ctx.globalAlpha = 0.08; ctx.strokeStyle = '#fff'; for (let i = 0; i < strokes; i++) { const a = (i / strokes) * Math.PI * 2; const x1 = center.x + Math.cos(a) * innerR; const y1 = center.y + Math.sin(a) * innerR; const x2 = center.x + Math.cos(a) * outerR; const y2 = center.y + Math.sin(a) * outerR; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); } ctx.globalAlpha = 1; }\n if (opts?.bevel) { ctx.lineWidth = Math.max(1, (outerR - innerR) * 0.06); ctx.strokeStyle = '#ffffff22'; ctx.beginPath(); ctx.arc(center.x, center.y, outerR * 0.98, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = '#00000066'; ctx.beginPath(); ctx.arc(center.x, center.y, innerR * 1.02, 0, Math.PI * 2); ctx.stroke(); }\n ctx.restore();\n}\n\nexport function drawGlowArc(ctx: CanvasRenderingContext2D, center: Point, radius: number, progress: number, theme: Theme) {\n const start = progress * Math.PI * 2; const end = start + Math.PI * 0.5; const grad = (ctx as any).createConicGradient ? (ctx as any).createConicGradient(start, center.x, center.y) : null;\n if (!grad) return; grad.addColorStop(0, '#ffffff66'); grad.addColorStop(0.5, theme.palette.accent + '99'); grad.addColorStop(1, '#ffffff00');\n ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.lineWidth = Math.max(2, radius * 0.06); ctx.strokeStyle = grad as unknown as string; ctx.beginPath(); ctx.arc(center.x, center.y, radius, start, end); ctx.stroke(); ctx.restore();\n}\n\n\n// =========================================\n// File: packages/luopan-react/src/Luopan.tsx (整合：拖拽旋转 + 节气边界飞星 + 金属/磁环特效)\n// =========================================\n'use client';\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport type { Layer, Theme } from '@qiflow/luopan-core/types';\nimport { MOUNTAIN_24 } from '@qiflow/luopan-core/constants/24mountains';\nimport { BAGUA_POSTERIOR } from '@qiflow/luopan-core/constants/bagua';\nimport { metalAncient } from './theme/metalAncient';\nimport { drawLayers } from './renderers/canvasRenderer';\nimport { getDpr } from './utils/dpr';\nimport { computeFlyingStars } from '@qiflow/luopan-core/flyingStars';\nimport { drawFlyingStarOverlay } from './layers/flyingStarOverlay';\nimport { buildFlyingStarRingLayer } from './layers/flyingStarRingLayer';\nimport { drawMetalBezel, drawGlowArc, isLowEndDevice } from './visual/metalEffects';\nimport { useDragRotate } from './hooks/useDragRotate';\n\nexport interface LuopanProps {\n size?: number; angle?: number; theme?: Theme; dpiScale?: number;\n showFlyingStarOverlay?: boolean; showFlyingStarRing?: boolean; interactive?: boolean;\n}\n\nexport const Luopan: React.FC<LuopanProps> = ({\n size = 360, angle, theme = metalAncient, dpiScale,\n showFlyingStarOverlay = true, showFlyingStarRing = false, interactive = true,\n}) => {\n const canvasRef = useRef<HTMLCanvasElement | null>(null);\n const dpr = getDpr(dpiScale);\n const [t, setT] = useState(0);\n const { angle: dragAngle } = useDragRotate(canvasRef, { enabled: interactive, snapStepDeg: 1 });\n const effectiveAngle = (typeof angle === 'number') ? angle : dragAngle;\n\n const layers = useMemo<Layer[]>(() => {\n const base: Layer[] = [\n { id: 'layer-24mountains', name: '24山', ringWidth: size * 0.18, cells: MOUNTAIN_24, style: { ringFill: theme.palette.ring, textFill: theme.palette.text, font: `600 ${Math.floor(size * 0.055)}px 'Noto Serif SC', 'Songti SC', serif` } },\n { id: 'layer-bagua', name: '后天八卦', ringWidth: size * 0.12, cells: BAGUA_POSTERIOR, style: { ringFill: '#3b2f1b', textFill: theme.palette.accent, font: `700 ${Math.floor(size * 0.06)}px 'Noto Serif SC', serif` } },\n ];\n if (showFlyingStarRing) {\n const chart = computeFlyingStars({ facingDeg: effectiveAngle, dateISO: new Date().toISOString(), boundaryStrategy: { useLichunForYear: true, useMonthlyBoundary: true } });\n base.unshift(buildFlyingStarRingLayer(chart, { ringWidth: size * 0.12, showAnnual: true, showMonthly: true }));\n }\n return base;\n }, [size, theme, effectiveAngle, showFlyingStarRing]);\n\n useEffect(() => {\n const canvas = canvasRef.current; if (!canvas) return;\n const logical = size; const radius = logical / 2 - Math.floor(logical * 0.04);\n canvas.width = Math.floor(logical * dpr); canvas.height = Math.floor(logical * dpr); canvas.style.width = `${logical}px`; canvas.style.height = `${logical}px`;\n const ctx = canvas.getContext('2d'); if (!ctx) return;\n\n // 背景\n ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = theme.palette.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);\n const cx = (canvas.width) / 2; const cy = (canvas.height) / 2;\n\n // 金属外圈（不随盘旋转）\n const bezelOuter = radius * dpr + Math.max(8, dpr * 6); const bezelInner = radius * dpr - Math.max(6, dpr * 4);\n drawMetalBezel(ctx, { x: cx, y: cy }, bezelOuter, bezelInner, theme, { brushed: !isLowEndDevice(), bevel: true });\n\n // 盘面旋转层\n ctx.save(); ctx.translate(cx, cy); ctx.rotate((effectiveAngle * Math.PI) / 180); ctx.translate(-cx, -cy);\n drawLayers({ ctx, center: { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 }, radius, dpr, theme, rotationDeg: effectiveAngle }, layers);\n ctx.restore();\n\n // 中心“磁环”高光弧（动画）\n if (!isLowEndDevice()) drawGlowArc(ctx, { x: cx, y: cy }, Math.max(10, radius * dpr * 0.14), t, theme);\n\n // 中心九宫覆盖\n if (showFlyingStarOverlay) {\n const chart = computeFlyingStars({ facingDeg: effectiveAngle, dateISO: new Date().toISOString(), boundaryStrategy: { useLichunForYear: true, useMonthlyBoundary: true } });\n drawFlyingStarOverlay(ctx, chart, { size, dpr, theme });\n }\n }, [size, dpr, theme, layers, t, showFlyingStarOverlay, effectiveAngle]);\n\n useEffect(() => { if (isLowEndDevice()) return; let raf = 0; let running = true; const tick = () => { setT(prev => (prev + 0.012) % 1); if (running) raf = requestAnimationFrame(tick); }; raf = requestAnimationFrame(tick); return () => { running = false; cancelAnimationFrame(raf); }; }, []);\n\n return <canvas ref={canvasRef} aria-label=\"Luopan Compass\" />;\n};\n\nexport default Luopan;\n"}
```
好了，所有你点名要的东西我都给你补齐并集成到同一个“增补包”里了（已放在右侧画布的代码文档里，直接拷到你的 monorepo 即可）：  
- 节气级**年/月星边界**（立春切年、按节/中气近似切月）  
- **飞星外环**（与 24 山并列）+ **中心九宫覆盖**  
- **金属拉丝外圈 + 浮雕刻线**、**中心“磁环”动态高光弧**（低端机自动降级）  
- **手势拖拽旋转 Hook**（单指/鼠标，带阻尼与吸附）

你可以这样用（最小集成示例）：
```tsx
<Luopan
size={360}
// 若不传 angle，则可直接用手势拖动旋转；也可传入受控 angle
showFlyingStarRing // 开启“飞星外环”
showFlyingStarOverlay // 开启“中心九宫”
interactive // 允许手势旋转
/>
```

## 接入与验证清单（一步到位）
1) **复制代码**
 - 把画布里的新增文件粘到你的 `packages/luopan-core` 与 `packages/luopan-react` 对应路径。
 - 注意 TS 别名（`@qiflow/luopan-core`）保持一致，或改成相对路径。

2) **飞星按节气边界**
 - 现在 `computeFlyingStars({ dateISO, boundaryStrategy })` 默认使用：
 - 年星：以**立春**（约 2/4）为界；
 - 月星：按每月 **MONTH_BOUNDARY_APPROX** 切换。
 - 生产想更准：后端提供精确节气 UTC 时间 → 替换 `splitYearByLichun` / `monthIdxByBoundary` 即可。

3) **低端机降级**
 - `isLowEndDevice()` 会关闭**拉丝**与**高光动画**，保留基本金属渐变与刻线。
 - 若想更激进：可以在低端机时把飞星中心九宫也关闭。

4) **交互**
 - 不传 `angle` 时，`<Luopan interactive />` 支持**单指/鼠标拖拽旋转**，带阻尼与 1° 吸附。
 - 你已有设备方向 Hook 的话，也可继续外部受控：`angle={heading}`。

5) **视觉微调**
 - 外圈金属层：在 `drawMetalBezel()` 可进一步调整**拉丝密度**、**高光半径**、**描边宽度**；
 - 磁环高光弧：在 `drawGlowArc()` 调 `end-start` 改高光弧长，或调动画步进 `0.012` 控制速度。

---

如果你愿意，我可以再给你补一份 **Storybook 配置 + 视觉回归（Playwright）** 脚手架，包含以下故事：
- 仅 24 山
- 24 山 + 飞星外环
- 中心九宫覆盖
- 主题切换（metalAncient / modernMinimal）
- 设备方向模拟/手势演示

要不要继续把 Storybook 和端到端截图回归也加上？
